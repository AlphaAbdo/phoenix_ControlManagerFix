{"version":3,"file":"969.48c2df7c7bfdcda2.js","mappings":"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","names":["THStackPainter","ObjectPainter","constructor","dom","stack","opt","super","this","firstpainter","painters","cleanup","getPadPainter","cleanPrimitives","objp","indexOf","buildStack","fHists","nhists","arr","length","lst","create","Add","clone","i","hnext","hnextopt","hprev","fNbins","fXaxis","fXmin","fXmax","console","warn","fName","Clear","n","fArray","fStack","getMinMax","iserr","res","min","max","getObject","pad","getRootPad","getHistMinMax","hist","witherr","domin","domax","fMinimum","fMaximum","i1","i2","j1","j2","first","TestBit","EAxisBits","fFirst","fLast","_typename","fYaxis","j","val","getBinContent","err","getBinError","getBin","options","nostack","resh","Math","gStyle","ndim","fLogy","fLogz","kmin","log10","kmax","drawNextHisto","indx","pad_painter","hlst","Promise","resolve","rindx","horder","hopt","fOption","toUpperCase","draw_errors","_pfc","_plc","_pmc","mp","getMainPainter","createAutoColor","icolor","fFillColor","fLineColor","fMarkerColor","subpad_painter","getSubPadPainter","prev_name","selectCurrentPad","this_pad_name","hdraw_func","getDom","then","subp","push","$baseh","decodeOptions","Object","assign","same","has_errors","fHistogram","hasErrors","fSumw2","k","nhist","d","DrawOptions","check","pads","remain","dolego","errors","createHistogram","histos","numhistos","histo","fTitle","h0","h","fLabels","updateObject","obj","matchObjectType","src","mm","minimum","maximum","ymin","ymax","did_update","redraw","static","painter","skip_drawing","ensureTCanvas","TH1Painter","TH2Painter","doingDraw","_pad_painter$pad","fPrimitives","log","p","divide"],"sourceRoot":"webpack:///","sources":["../../node_modules/jsroot/modules/hist/THStackPainter.mjs"],"sourcesContent":["import { clone, create, createHistogram, gStyle } from '../core.mjs';\nimport { DrawOptions } from '../base/BasePainter.mjs';\nimport { ObjectPainter } from '../base/ObjectPainter.mjs';\nimport { TH1Painter } from './TH1Painter.mjs';\nimport { TH2Painter } from './TH2Painter.mjs';\nimport { EAxisBits } from '../gpad/TAxisPainter.mjs';\nimport { ensureTCanvas } from '../gpad/TCanvasPainter.mjs';\n\n\n/**\n * @summary Painter class for THStack\n *\n * @private\n */\n\nclass THStackPainter extends ObjectPainter {\n\n   /** @summary constructor\n     * @param {object|string} dom - DOM element for drawing or element id\n     * @param {object} stack - THStack object\n     * @param {string} [opt] - draw options */\n   constructor(dom, stack, opt) {\n      super(dom, stack, opt);\n      this.firstpainter = null;\n      this.painters = []; // keep painters to be able update objects\n   }\n\n   /** @summary Cleanup THStack painter */\n   cleanup() {\n      this.getPadPainter()?.cleanPrimitives(objp => { return (objp === this.firstpainter) || (this.painters.indexOf(objp) >= 0); });\n      delete this.firstpainter;\n      delete this.painters;\n      super.cleanup();\n   }\n\n   /** @summary Build sum of all histograms\n     * @desc Build a separate list fStack containing the running sum of all histograms */\n   buildStack(stack) {\n      if (!stack.fHists) return false;\n      let nhists = stack.fHists.arr.length;\n      if (nhists <= 0) return false;\n      let lst = create(\"TList\");\n      lst.Add(clone(stack.fHists.arr[0]), stack.fHists.opt[0]);\n      for (let i = 1; i < nhists; ++i) {\n         let hnext = clone(stack.fHists.arr[i]),\n             hnextopt = stack.fHists.opt[i],\n             hprev = lst.arr[i-1];\n\n         if ((hnext.fNbins != hprev.fNbins) ||\n             (hnext.fXaxis.fXmin != hprev.fXaxis.fXmin) ||\n             (hnext.fXaxis.fXmax != hprev.fXaxis.fXmax)) {\n            console.warn(`When drawing THStack, cannot sum-up histograms ${hnext.fName} and ${hprev.fName}`);\n            lst.Clear();\n            return false;\n         }\n\n         // trivial sum of histograms\n         for (let n = 0; n < hnext.fArray.length; ++n)\n            hnext.fArray[n] += hprev.fArray[n];\n\n         lst.Add(hnext, hnextopt);\n      }\n      stack.fStack = lst;\n      return true;\n   }\n\n   /** @summary Returns stack min/max values */\n   getMinMax(iserr) {\n      let res = { min: 0, max: 0 },\n          stack = this.getObject(),\n          pad = this.getPadPainter().getRootPad(true);\n\n      const getHistMinMax = (hist, witherr) => {\n         let res = { min: 0, max: 0 },\n             domin = true, domax = true;\n         if (hist.fMinimum !== -1111) {\n            res.min = hist.fMinimum;\n            domin = false;\n         }\n         if (hist.fMaximum !== -1111) {\n            res.max = hist.fMaximum;\n            domax = false;\n         }\n\n         if (!domin && !domax) return res;\n\n         let i1 = 1, i2 = hist.fXaxis.fNbins, j1 = 1, j2 = 1, first = true;\n\n         if (hist.fXaxis.TestBit(EAxisBits.kAxisRange)) {\n            i1 = hist.fXaxis.fFirst;\n            i2 = hist.fXaxis.fLast;\n         }\n\n         if (hist._typename.indexOf(\"TH2\")===0) {\n            j2 = hist.fYaxis.fNbins;\n            if (hist.fYaxis.TestBit(EAxisBits.kAxisRange)) {\n               j1 = hist.fYaxis.fFirst;\n               j2 = hist.fYaxis.fLast;\n            }\n         }\n         for (let j = j1; j <= j2; ++j)\n            for (let i = i1; i <= i2; ++i) {\n               let val = hist.getBinContent(i, j),\n                   err = witherr ? hist.getBinError(hist.getBin(i,j)) : 0;\n               if (domin && (first || (val-err < res.min))) res.min = val-err;\n               if (domax && (first || (val+err > res.max))) res.max = val+err;\n               first = false;\n           }\n\n         return res;\n      };\n\n      if (this.options.nostack) {\n         for (let i = 0; i < stack.fHists.arr.length; ++i) {\n            let resh = getHistMinMax(stack.fHists.arr[i], iserr);\n            if (i == 0) {\n               res = resh;\n             } else {\n               res.min = Math.min(res.min, resh.min);\n               res.max = Math.max(res.max, resh.max);\n            }\n         }\n      } else {\n         res.min = getHistMinMax(stack.fStack.arr[0], iserr).min;\n         res.max = getHistMinMax(stack.fStack.arr[stack.fStack.arr.length-1], iserr).max;\n      }\n\n      if (stack.fMaximum != -1111) res.max = stack.fMaximum;\n      res.max *= (1 + gStyle.fHistTopMargin);\n      if (stack.fMinimum != -1111) res.min = stack.fMinimum;\n\n      if (pad && (this.options.ndim == 1 ? pad.fLogy : pad.fLogz)) {\n         if (res.max<=0) res.max = 1;\n         if (res.min<=0) res.min = 1e-4*res.max;\n         let kmin = 1/(1 + 0.5*Math.log10(res.max / res.min)),\n             kmax = 1 + 0.2*Math.log10(res.max / res.min);\n         res.min *= kmin;\n         res.max *= kmax;\n      } else {\n         if ((res.min>0) && (res.min < 0.05*res.max)) res.min = 0;\n      }\n\n      return res;\n   }\n\n   /** @summary Draw next stack histogram */\n   drawNextHisto(indx, pad_painter) {\n\n      let stack = this.getObject(),\n          hlst = this.options.nostack ? stack.fHists : stack.fStack,\n          nhists = (hlst && hlst.arr) ? hlst.arr.length : 0;\n\n      if (indx >= nhists)\n         return Promise.resolve(this);\n\n      let rindx = this.options.horder ? indx : nhists-indx-1,\n          hist = hlst.arr[rindx],\n          hopt = hlst.opt[rindx] || hist.fOption || this.options.hopt;\n\n      if (hopt.toUpperCase().indexOf(this.options.hopt) < 0)\n         hopt += ' ' + this.options.hopt;\n      if (this.options.draw_errors && !hopt)\n         hopt = \"E\";\n\n      if (this.options._pfc || this.options._plc || this.options._pmc) {\n         let mp = this.getMainPainter();\n         if (typeof mp?.createAutoColor == 'function') {\n            let icolor = mp.createAutoColor(nhists);\n            if (this.options._pfc) hist.fFillColor = icolor;\n            if (this.options._plc) hist.fLineColor = icolor;\n            if (this.options._pmc) hist.fMarkerColor = icolor;\n         }\n      }\n\n      // handling of \"pads\" draw option\n      if (pad_painter) {\n         let subpad_painter = pad_painter.getSubPadPainter(indx+1);\n         if (!subpad_painter)\n            return Promise.resolve(this);\n\n         let prev_name = subpad_painter.selectCurrentPad(subpad_painter.this_pad_name);\n\n         return this.hdraw_func(subpad_painter.getDom(), hist, hopt).then(subp => {\n            this.painters.push(subp);\n            subpad_painter.selectCurrentPad(prev_name);\n            return this.drawNextHisto(indx+1, pad_painter);\n         });\n      }\n\n      // special handling of stacked histograms - set $baseh object for correct drawing\n      // also used to provide tooltips\n      if ((rindx > 0) && !this.options.nostack)\n         hist.$baseh = hlst.arr[rindx - 1];\n\n      return this.hdraw_func(this.getDom(), hist, hopt + \" same nostat\").then(subp => {\n          this.painters.push(subp);\n          return this.drawNextHisto(indx+1, pad_painter);\n      });\n   }\n\n   /** @summary Decode draw options of THStack painter */\n   decodeOptions(opt) {\n      if (!this.options) this.options = {};\n      Object.assign(this.options, { ndim: 1, nostack: false, same: false, horder: true, has_errors: false, draw_errors: false, hopt: \"\" });\n\n      let stack = this.getObject(),\n          hist = stack.fHistogram || (stack.fHists ? stack.fHists.arr[0] : null) || (stack.fStack ? stack.fStack.arr[0] : null);\n\n      const hasErrors = hist => {\n         if (hist.fSumw2 && (hist.fSumw2.length > 0))\n            for (let n = 0;n < hist.fSumw2.length; ++n)\n               if (hist.fSumw2[n] > 0) return true;\n         return false;\n      };\n\n      if (hist && (hist._typename.indexOf(\"TH2\")==0)) this.options.ndim = 2;\n\n      if ((this.options.ndim == 2) && !opt) opt = \"lego1\";\n\n      if (stack.fHists && !this.options.nostack)\n         for (let k = 0; k < stack.fHists.arr.length; ++k)\n            this.options.has_errors = this.options.has_errors || hasErrors(stack.fHists.arr[k]);\n\n      this.options.nhist = stack.fHists ? stack.fHists.arr.length : 1;\n\n      let d = new DrawOptions(opt);\n\n      this.options.nostack = d.check(\"NOSTACK\");\n      if (d.check(\"STACK\")) this.options.nostack = false;\n      this.options.same = d.check(\"SAME\");\n\n      d.check(\"NOCLEAR\"); // ignore noclear option\n\n      this.options._pfc = d.check(\"PFC\");\n      this.options._plc = d.check(\"PLC\");\n      this.options._pmc = d.check(\"PMC\");\n\n      this.options.pads = d.check(\"PADS\");\n      if (this.options.pads) this.options.nostack = true;\n\n      this.options.hopt = d.remain(); // use remaining draw options for histogram draw\n\n      let dolego = d.check(\"LEGO\");\n\n      this.options.errors = d.check(\"E\");\n\n      // if any histogram appears with pre-calculated errors, use E for all histograms\n      if (!this.options.nostack && this.options.has_errors && !dolego && !d.check(\"HIST\") && (this.options.hopt.indexOf(\"E\")<0)) this.options.draw_errors = true;\n\n      this.options.horder = this.options.nostack || dolego;\n   }\n\n   /** @summary Create main histogram for THStack axis drawing */\n   createHistogram(stack) {\n      let histos = stack.fHists,\n          numhistos = histos ? histos.arr.length : 0;\n\n      if (!numhistos) {\n         let histo = createHistogram(\"TH1I\", 100);\n         histo.fTitle = stack.fTitle;\n         return histo;\n      }\n\n      let h0 = histos.arr[0],\n          histo = createHistogram((this.options.ndim==1) ? \"TH1I\" : \"TH2I\", h0.fXaxis.fNbins, h0.fYaxis.fNbins);\n      histo.fName = \"axis_hist\";\n      Object.assign(histo.fXaxis, h0.fXaxis);\n      if (this.options.ndim==2)\n         Object.assign(histo.fYaxis, h0.fYaxis);\n\n      // this code is not exists in ROOT painter, can be skipped?\n      for (let n=1;n<numhistos;++n) {\n         let h = histos.arr[n];\n\n         if (!histo.fXaxis.fLabels) {\n            histo.fXaxis.fXmin = Math.min(histo.fXaxis.fXmin, h.fXaxis.fXmin);\n            histo.fXaxis.fXmax = Math.max(histo.fXaxis.fXmax, h.fXaxis.fXmax);\n         }\n\n         if ((this.options.ndim==2) && !histo.fYaxis.fLabels) {\n            histo.fYaxis.fXmin = Math.min(histo.fYaxis.fXmin, h.fYaxis.fXmin);\n            histo.fYaxis.fXmax = Math.max(histo.fYaxis.fXmax, h.fYaxis.fXmax);\n         }\n      }\n\n      histo.fTitle = stack.fTitle;\n\n      return histo;\n   }\n\n   /** @summary Update thstack object */\n   updateObject(obj) {\n      if (!this.matchObjectType(obj)) return false;\n\n      let stack = this.getObject();\n\n      stack.fHists = obj.fHists;\n      stack.fStack = obj.fStack;\n      stack.fTitle = obj.fTitle;\n\n      if (!this.options.nostack)\n         this.options.nostack = !this.buildStack(stack);\n\n      if (this.firstpainter) {\n         let src = obj.fHistogram;\n         if (!src)\n            src = stack.fHistogram = this.createHistogram(stack);\n\n         this.firstpainter.updateObject(src);\n\n         let mm = this.getMinMax(this.options.errors || this.options.draw_errors);\n\n         this.firstpainter.options.minimum = mm.min;\n         this.firstpainter.options.maximum = mm.max;\n\n         if (this.options.ndim == 1) {\n            this.firstpainter.ymin = mm.min;\n            this.firstpainter.ymax = mm.max;\n         }\n      }\n\n      // and now update histograms\n      let hlst = this.options.nostack ? stack.fHists : stack.fStack,\n          nhists = (hlst && hlst.arr) ? hlst.arr.length : 0;\n\n      if (nhists !== this.painters.length) {\n         this.getPadPainter()?.cleanPrimitives(objp => { return this.painters.indexOf(objp) >= 0; });\n         this.painters = [];\n         this.did_update = true;\n      } else {\n         for (let indx = 0; indx < nhists; ++indx) {\n            let rindx = this.options.horder ? indx : nhists-indx-1;\n            let hist = hlst.arr[rindx];\n            this.painters[indx].updateObject(hist);\n         }\n      }\n\n      return true;\n   }\n\n   /** @summary Redraw THStack\n     * @desc Do something if previous update had changed number of histograms */\n   redraw() {\n      if (this.did_update) {\n         delete this.did_update;\n         return this.drawNextHisto(0, this.options.pads ? this.getPadPainter() : null);\n      }\n   }\n\n   /** @summary draw THStack object */\n   static draw(dom, stack, opt) {\n      if (!stack.fHists || !stack.fHists.arr)\n         return null; // drawing not needed\n\n      let painter = new THStackPainter(dom, stack, opt),\n          pad_painter = null,\n          skip_drawing = false;\n\n      return ensureTCanvas(painter, false).then(() => {\n\n         painter.decodeOptions(opt);\n\n         painter.hdraw_func = (painter.options.ndim == 1) ? TH1Painter.draw : TH2Painter.draw;\n\n         if (painter.options.pads) {\n            pad_painter = painter.getPadPainter();\n            if (pad_painter.doingDraw() && pad_painter.pad?.fPrimitives &&\n                pad_painter.pad.fPrimitives.arr.length > 1 && (pad_painter.pad.fPrimitives.arr.indexOf(stack) == 0)) {\n               skip_drawing = true;\n               console.log('special case with THStack with is already rendered - do nothing');\n               return;\n            }\n\n            pad_painter.cleanPrimitives(p => p !== painter);\n            return pad_painter.divide(painter.options.nhist);\n         }\n\n         if (!painter.options.nostack)\n             painter.options.nostack = !painter.buildStack(stack);\n\n         if (painter.options.same) return;\n\n         if (!stack.fHistogram)\n             stack.fHistogram = painter.createHistogram(stack);\n\n         let mm = painter.getMinMax(painter.options.errors || painter.options.draw_errors),\n             hopt = painter.options.hopt + \" axis\";\n\n         if (mm) hopt += \";minimum:\" + mm.min + \";maximum:\" + mm.max;\n\n         return painter.hdraw_func(dom, stack.fHistogram, hopt).then(subp => {\n            painter.firstpainter = subp;\n         });\n      }).then(() => skip_drawing ? painter : painter.drawNextHisto(0, pad_painter));\n   }\n\n} // class THStackPainter\n\nexport { THStackPainter }\n"],"x_google_ignoreList":[0]}
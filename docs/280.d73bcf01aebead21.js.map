{"version":3,"file":"280.d73bcf01aebead21.js","mappings":"+MAaA,MAAMA,UAA0BC,KAG7BC,cACqBC,IAAdC,KAAKC,MAAoBD,KAAKE,cACrC,CAGAC,cAAcC,GACX,MAAMC,EAAI,IAAIC,KAAYF,GAAO,UAE5BJ,KAAKO,UAASP,KAAKO,QAAU,CAAC,GAEnCC,OAAOC,OAAOT,KAAKO,QAAS,CACxBG,KAAML,EAAEM,MAAM,QACdC,OAAQP,EAAEM,MAAM,UAChBE,MAAOR,EAAEM,MAAM,WAGnBX,KAAKc,aAAaV,EACrB,CAGMW,eAAeC,GAAM,IAAAC,EAAAjB,KAAA,SAAAkB,KAAA,YACnBF,IACFA,EAAO,EACPC,EAAKE,mBAAoB,GAG5B,MAAMC,EAAMH,EAAKI,aAAaC,OAAOC,IAAIN,EAAKhB,MAE9C,GAAKmB,KAAQJ,GAAQI,EAAIG,IAAIC,QAK7B,SAAOC,MAAKR,EAAKS,gBAAiBN,EAAIG,IAAIP,GAAOI,EAAIhB,IAAIY,IAAOW,KAAKC,IAC9DA,IACDA,EAAEC,UAAYZ,EAAKa,OACnBF,EAAEG,QAAUd,EAAKhB,MAEbgB,EAAKF,eAAeC,EAAK,YATzBC,EAAKE,iBAUZ,EAnBqB,EAoB3B,CAGAa,kBACG,IAAKhC,KAAKO,QAAS,OAEnB,MAAM0B,EAAKjC,KAAKqB,YAEhB,GAAIrB,KAAKO,QAAQM,aAEPb,KAAKC,UAIf,GAAID,KAAKkC,qBAAsB,QACrBlC,KAAKkC,qBAGZ,MAAMC,EAAKnC,KAAK0B,gBAChB,IAAKS,EAGF,mBADOnC,KAAKC,KAKfD,KAAKe,iBAAiBY,KAAK,KAExBQ,EAAGC,gBAAgBR,GAAeA,EAAEC,YAAc7B,KAAK8B,QAAYF,EAAEG,UAAY/B,KAAKC,MAEtFD,KAAKgC,iBAAgB,EAE3B,SAAWhC,KAAKqC,gBACbC,aAAatC,KAAKqC,wBACXrC,KAAKqC,gBAEZrC,KAAKkC,sBAAuB,EAE5BK,sBAAsB,IAAMvC,KAAKgC,uBAC7B,CACJ,IAAIQ,EAAYC,KAAKC,IAAIT,EAAGU,WAAY,IAExC,KAAM3C,KAAKC,KAAOgC,EAAGX,OAAOC,IAAIC,OAC7B,KAAIxB,KAAKO,QAAQK,OAKd,mBADOZ,KAAKC,KAHZD,KAAKC,KAAO,EACZuC,EAAYC,KAAKC,IAAI,IAAM,EAAEF,EAIhC,CAGHxC,KAAKqC,gBAAkBO,WAAW,IAAM5C,KAAKgC,kBAAmBQ,EACnE,CACH,CAGAtC,eACG,OAAAF,KAAKC,KAAO,EAELD,KAAKe,iBAAiBY,KAAK,KAC/B3B,KAAKgC,kBACEhC,MAEb,CAGA,WAAayB,CAAKoB,EAAKZ,EAAI7B,GAAK,SAAAc,KAAA,YAC7B,IAAKe,EAAGa,OACNC,eAAQC,MAAM,8BACP,KAGT,MAAMC,EAAU,IAAIrD,EAAkBiD,EAAKZ,GAE3C,GAAIgB,EAAQC,iBACTH,eAAQC,MAAM,qDACP,KAKV,GAFAC,EAAQ9C,cAAcC,IAEjB6B,EAAGa,OAAOK,QAAUlB,EAAGkB,OAAQ,CACjC,MAAM5B,EAAMU,EAAGkB,OAAOC,MAAM,KAC5BnB,EAAGa,OAAOK,OAAS5B,EAAI,GACnBA,EAAI,KAAIU,EAAGa,OAAOO,OAAOF,OAAS5B,EAAI,IACtCA,EAAI,KAAIU,EAAGa,OAAOQ,OAAOH,OAAS5B,EAAI,GAC7C,CAEA0B,SAAQnB,OAAS,UAAYyB,YAAUC,aAEhCC,IAAWhC,KAAKoB,EAAKZ,EAAGa,OAAQ,IAAInB,KAAK,KAC7CsB,EAAQS,qBACDT,EAAQ/C,gBACf,EA3B0B,EA4BhC","names":["TGraphTimePainter","ObjectPainter","redraw","undefined","this","step","startDrawing","decodeOptions","opt","d","DrawOptions","options","Object","assign","once","check","repeat","first","storeDrawOpt","drawPrimitives","indx","_this","_asyncToGenerator","_doing_primitives","lst","getObject","fSteps","arr","length","draw","getPadPainter","then","p","$grtimeid","selfid","$grstep","continueDrawing","gr","wait_animation_frame","pp","cleanPrimitives","running_timeout","clearTimeout","requestAnimationFrame","sleeptime","Math","max","fSleepTime","setTimeout","dom","fFrame","console","error","painter","getMainPainter","fTitle","split","fXaxis","fYaxis","internals","id_counter","TH1Painter","addToPadPrimitives"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/hist/TGraphTimePainter.mjs"],"sourcesContent":["import { internals } from '../core.mjs';\nimport { DrawOptions } from '../base/BasePainter.mjs';\nimport { ObjectPainter } from '../base/ObjectPainter.mjs';\nimport { TH1Painter } from '../hist2d/TH1Painter.mjs';\nimport { draw } from '../draw.mjs';\n\n\n/**\n * @summary Painter for TGraphTime object\n *\n * @private\n */\n\nclass TGraphTimePainter extends ObjectPainter {\n\n   /** @summary Redraw object */\n   redraw() {\n      if (this.step === undefined) this.startDrawing();\n   }\n\n   /** @summary Decode drawing options */\n   decodeOptions(opt) {\n      const d = new DrawOptions(opt || 'REPEAT');\n\n      if (!this.options) this.options = {};\n\n      Object.assign(this.options, {\n          once: d.check('ONCE'),\n          repeat: d.check('REPEAT'),\n          first: d.check('FIRST')\n      });\n\n      this.storeDrawOpt(opt);\n   }\n\n   /** @summary Draw primitives */\n   async drawPrimitives(indx) {\n      if (!indx) {\n         indx = 0;\n         this._doing_primitives = true;\n      }\n\n      const lst = this.getObject()?.fSteps.arr[this.step];\n\n      if (!lst || (indx >= lst.arr.length)) {\n         delete this._doing_primitives;\n         return;\n      }\n\n      return draw(this.getPadPainter(), lst.arr[indx], lst.opt[indx]).then(p => {\n         if (p) {\n            p.$grtimeid = this.selfid; // indicator that painter created by ourself\n            p.$grstep = this.step; // remember step\n         }\n         return this.drawPrimitives(indx+1);\n      });\n   }\n\n   /** @summary Continue drawing */\n   continueDrawing() {\n      if (!this.options) return;\n\n      const gr = this.getObject();\n\n      if (this.options.first) {\n         // draw only single frame, cancel all others\n         delete this.step;\n         return;\n      }\n\n      if (this.wait_animation_frame) {\n         delete this.wait_animation_frame;\n\n         // clear pad\n         const pp = this.getPadPainter();\n         if (!pp) {\n            // most probably, pad is cleared\n            delete this.step;\n            return;\n         }\n\n         // draw primitives again\n         this.drawPrimitives().then(() => {\n            // clear primitives produced by previous drawing to avoid flicking\n            pp.cleanPrimitives(p => { return (p.$grtimeid === this.selfid) && (p.$grstep !== this.step); });\n\n            this.continueDrawing();\n         });\n      } else if (this.running_timeout) {\n         clearTimeout(this.running_timeout);\n         delete this.running_timeout;\n\n         this.wait_animation_frame = true;\n         // use animation frame to disable update in inactive form\n         requestAnimationFrame(() => this.continueDrawing());\n      } else {\n         let sleeptime = Math.max(gr.fSleepTime, 10);\n\n         if (++this.step > gr.fSteps.arr.length) {\n            if (this.options.repeat) {\n               this.step = 0; // start again\n               sleeptime = Math.max(5000, 5*sleeptime); // increase sleep time\n            } else {\n               delete this.step;    // clear indicator that animation running\n               return;\n            }\n         }\n\n         this.running_timeout = setTimeout(() => this.continueDrawing(), sleeptime);\n      }\n   }\n\n   /** @summary Start drawing of graph time */\n   startDrawing() {\n      this.step = 0;\n\n      return this.drawPrimitives().then(() => {\n         this.continueDrawing();\n         return this;\n      });\n   }\n\n   /** @summary Draw TGraphTime object */\n   static async draw(dom, gr, opt) {\n      if (!gr.fFrame) {\n        console.error('Frame histogram not exists');\n        return null;\n      }\n\n      const painter = new TGraphTimePainter(dom, gr);\n\n      if (painter.getMainPainter()) {\n         console.error('Cannot draw graph time on top of other histograms');\n         return null;\n      }\n\n      painter.decodeOptions(opt);\n\n      if (!gr.fFrame.fTitle && gr.fTitle) {\n         const arr = gr.fTitle.split(';');\n         gr.fFrame.fTitle = arr[0];\n         if (arr[1]) gr.fFrame.fXaxis.fTitle = arr[1];\n         if (arr[2]) gr.fFrame.fYaxis.fTitle = arr[2];\n      }\n\n      painter.selfid = 'grtime_' + internals.id_counter++; // use to identify primitives which should be clean\n\n      return TH1Painter.draw(dom, gr.fFrame, '').then(() => {\n         painter.addToPadPrimitives();\n         return painter.startDrawing();\n      });\n   }\n\n} // class TGraphTimePainter\n\nexport { TGraphTimePainter };\n"],"x_google_ignoreList":[0]}
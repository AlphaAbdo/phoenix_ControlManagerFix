{"version":3,"file":"common.8e2e31536ed7c14a.js","mappings":"oXAYA,SAASA,IACN,IAAIC,EAAOC,KAAKC,YACZC,EAAKF,KAAKG,gBACVC,EAAIF,EAAGG,cACPC,EAAIJ,EAAGK,eACPC,EAAQT,EAAKU,GAAIC,EAAQX,EAAKY,GAC9BC,EAASZ,KAAKa,SAASd,EAAKe,YAC5BC,GAAY,EACZC,EAAO,EAAIC,EAAWlB,EAAKmB,WAAa,IACxCC,EAAOnB,KAAKoB,kBAEZrB,EAAKsB,WAAQC,OAAI,KAElBtB,KAAKuB,OAAQ,EACLJ,IAASA,EAAKK,QAEtBpB,EAAIe,EAAKM,gBACTnB,EAAIa,EAAKO,iBACTX,EAAY,eACJb,EAAGyB,YAAW,KAItB3B,KAAKuB,OAAQ,EACbf,EAAQE,EAAQ,GAChBX,EAAK6B,WAAa,GACbhB,IAAQA,EAAS,UAGzBZ,KAAK6B,QAAQd,GAEbf,KAAK8B,OAAOC,KAAK,YAAa,MAE9B/B,KAAKQ,MAAQR,KAAKgC,UAAU,IAAKxB,EAAOR,KAAKuB,OAC7CvB,KAAKU,MAAQV,KAAKgC,UAAU,IAAKtB,EAAOV,KAAKuB,OAE7C,IAAIU,EAAM,CAAEC,MAAOnC,EAAK6B,WAAYO,EAAGnC,KAAKQ,MAAO4B,EAAGpC,KAAKU,MAAOX,KAAMA,EAAKsC,OAAQC,MAAO1B,EAAQ2B,MAAO,GAE3G,OAAIxC,EAAKyC,aAAYP,EAAIQ,QAAU1C,EAAKyC,YAElB,UAAlBzC,EAAK2C,WAAyBT,EAAIM,MAAQ,EAAGvB,EAAO,IAClC,aAAlBjB,EAAK2C,YAA4BT,EAAIM,MAAQ,EAAGvB,EAAO,IAE3DhB,KAAK2C,iBAAiB5C,EAAK6C,UAAWC,KAAKC,MAAO7B,EAAS,EAAKA,EAAWA,EAAS4B,KAAKE,IAAI3C,EAAEE,GAAGU,IAElGhB,KAAKF,SAASmC,GAEPjC,KAAKgD,oBAAoBC,KAAK,QAC9BC,mBAEJlD,KAAKmD,OAASnD,KAAKoD,OAAS,EAEvBpD,KAAKqD,WACPrD,KAAKqD,SAAW,SAASC,EAAGC,GACzBvD,KAAKmD,QAAUG,EACftD,KAAKoD,QAAUG,EACfvD,KAAK8B,OAAOC,KAAK,YAAc,aAAY/B,KAAKmD,UAAUnD,KAAKoD,UAClE,GAEEpD,KAAKwD,UACPxD,KAAKwD,QAAU,SAASC,GACrB,GAAIA,EAAa,OACjB,IAAI1D,EAAOC,KAAKC,YAChBF,EAAKU,GAAKT,KAAK0D,UAAU,IAAK1D,KAAKQ,MAAQR,KAAKmD,OAAQnD,KAAKuB,OAC7DxB,EAAKY,GAAKX,KAAK0D,UAAU,IAAK1D,KAAKU,MAAQV,KAAKoD,OAAQpD,KAAKuB,OAC7DvB,KAAK2D,eAAgB,QAAO5D,EAAKU,aAAaV,EAAKY,QACrD,MAEJiD,KAAe5D,OApBWA,MAwB/B,CAID,SAAS6D,EAAUC,EAAKC,GAErB,IAAIC,EAAU,IAAIC,KAAcH,EAAKC,GAErCC,SAAQE,OAAS,WACd,MAAMC,KAAW7C,OAAI,IACf8C,EAAOpE,KAAKC,YACZoE,EAAU,IAAIC,KAAgBF,GAC9B7C,EAAQ6C,EAAK/C,QAAQ8C,GAG3B,YAAKtC,UAEL7B,KAAK8B,OACAyC,OAAO,YACPxC,KAAK,IAAM,IAAG/B,KAAKgC,UAAU,IAAKoC,EAAKI,IAAKjD,MAAUvB,KAAKgC,UAAU,IAAKoC,EAAKK,IAAKlD,MAAUvB,KAAKgC,UAAU,IAAKoC,EAAKM,IAAKnD,MAAUvB,KAAKgC,UAAU,IAAKoC,EAAKO,IAAKpD,MACpKqD,KAAKP,EAAQQ,MAEX7E,IACT,KAEM8E,iBAAcd,GAAS,GAAOf,KAAK,IAAMe,EAAQE,SAC1D,CAID,SAASa,IAGN/E,KAAK6B,UAEL,IAAImD,EAAWhF,KAAKC,YAChBoE,EAAU,IAAIC,KAAgBU,GAC9BC,EAAUjF,KAAKkF,cAAcF,GAC7BG,KAAe7D,OAAI,IACnBC,EAAQyD,EAAS3D,QAAQ8D,GACzBC,EAAM,GAAIP,EAAO7E,KAAKqF,iBAAiB9D,GAE3C,QAAS+D,EAAI,EAAGA,GAAKN,EAASO,aAAcD,EACzCF,IAASE,EAAI,EAAK,IAAM,KAAOT,EAAK1C,EAAE6C,EAASvE,GAAG6E,IAAM,IAAMT,EAAKzC,EAAE4C,EAASrE,GAAG2E,IAE1D,aAAtBN,EAAStC,WAA0BuC,EAAQO,cAAc,QAExDP,EAAQQ,UAASL,GAAK,KAE3BpF,KAAK8B,OACAyC,OAAO,YACPxC,KAAK,IAAKqD,GACVR,KAAKP,EAAQQ,MACbD,KAAKK,EAAQJ,KACpB,CAID,SAASa,IAEN,IAAIC,EAAU3F,KAAKC,YAEnBD,KAAK4F,cAAc,CAAE7D,KAAM4D,IAC3B3F,KAAKkF,cAAc,CAAEnD,KAAM4D,IAG3B3F,KAAK6B,UAEL,IAAIgE,EAAQ7F,KAAKqF,mBACblD,EAAI0D,EAAM1D,EAAEwD,EAAQnB,KACpBpC,EAAIyD,EAAMzD,EAAEuD,EAAQlB,KACpBqB,EAAKD,EAAM1D,EAAEwD,EAAQnB,IAAMmB,EAAQI,KAAO5D,EAC1C6D,EAAK5D,EAAIyD,EAAMzD,EAAEuD,EAAQlB,IAAMkB,EAAQM,KACvCC,EAAO,GAAIC,EAAqC,GAAnBR,EAAQS,SAAqC,KAAnBT,EAAQU,QAMnE,GAH0B,UAArBV,EAAQjD,WAA2BiD,EAAQI,KAAO,IACpDD,EAAKD,EAAM1D,EAAEwD,EAAQnB,IAAMmB,EAAQM,KAAO9D,GAEnB,UAArBwD,EAAQjD,WAA2BiD,EAAQI,IAAM,EAAI,CACvD,IAAIO,EAAMR,EAAIS,EAAMP,EAChBQ,EAAMpE,EAAIyD,EAAMzD,EAAEuD,EAAQlB,IAAMkB,EAAQI,KACxCU,EAAMZ,EAAM1D,EAAEwD,EAAQnB,IAAMmB,EAAQM,KAAO9D,EAE/C,GAAIgE,EACDD,EAAQ,KAAII,OAASA,KAAOE,WAAaF,OAASA,KAAOE,YAAcF,QAC3DG,OAASA,KAAOF,WAAaE,OAASA,KAAOF,YAAcE,UACnE,CACJ,IAAIC,EAAaf,EAAQU,QAAQV,EAAQS,SAAS,IAAO,EAAI,EACzDO,EAAKhB,EAAQS,QAAQvD,KAAK+D,GAAG,IAAKC,EAAKlB,EAAQU,QAAQxD,KAAK+D,GAAG,IAC/DE,EAAMjE,KAAKC,MAAMwD,EAAIzD,KAAKkE,IAAIJ,IAAMK,EAAMnE,KAAKC,MAAM0D,EAAI3D,KAAKoE,IAAIN,IAKtET,EAAQ,IAJErD,KAAKC,MAAMwD,EAAIzD,KAAKkE,IAAIF,OAAYhE,KAAKC,MAAM0D,EAAI3D,KAAKoE,IAAIJ,OAI7CP,KAAOE,OAASE,OAAeI,KAAOE,KAHrDnE,KAAKC,MAAM2D,EAAI5D,KAAKkE,IAAIJ,OAAY9D,KAAKC,MAAMyD,EAAI1D,KAAKoE,IAAIN,OAI7CF,KAAOF,OAASG,OAH/B7D,KAAKC,MAAM2D,EAAI5D,KAAKkE,IAAIF,OAAYhE,KAAKC,MAAMyD,EAAI1D,KAAKoE,IAAIJ,MAIxE,CACH,SAA4B,GAAlBlB,EAAQuB,OAEbhB,EADCC,EACO,KAAIL,OAAQA,KAAME,WAAYF,OAAQA,KAAME,YAAaF,OAMzD,QAJCjD,KAAKC,MAAMgD,EAAKjD,KAAKkE,IAAIpB,EAAQS,QAAQvD,KAAK+D,GAAG,SACjD/D,KAAKC,MAAMkD,EAAKnD,KAAKoE,IAAItB,EAAQS,QAAQvD,KAAK+D,GAAG,SAG/Bd,KAAME,WAFxBnD,KAAKC,MAAMgD,EAAKjD,KAAKkE,IAAIpB,EAAQU,QAAQxD,KAAK+D,GAAG,SACjD/D,KAAKC,MAAMkD,EAAKnD,KAAKoE,IAAItB,EAAQU,QAAQxD,KAAK+D,GAAG,aAGzD,CACL,IAAIO,EAAKtE,KAAKkE,IAAIpB,EAAQuB,OAAOrE,KAAK+D,GAAG,KACrCQ,EAAKvE,KAAKoE,IAAItB,EAAQuB,OAAOrE,KAAK+D,GAAG,KACrCS,EAAO1B,EAAQS,QAAQvD,KAAK+D,GAAG,IAE/BU,EAAK,IACLC,GAFO5B,EAAQU,QAAQxD,KAAK+D,GAAG,IAElBS,IAASC,GAAMnB,EAAiB,EAAI,IACjDqB,EAAQ,EAAGC,EAAQ,EAClBtB,IAAgBD,EAAO,QAC5B,QAASZ,EAAI,EAAGA,EAAIgC,IAAMhC,EAAG,CACzB,IAAIoC,EAAQL,EAAO/B,EAAEiC,EACjBjE,EAAKqC,EAAQI,IAAMlD,KAAKkE,IAAIW,GAC5BnE,EAAKoC,EAAQM,IAAMpD,KAAKoE,IAAIS,GAC5BC,EAAK9B,EAAM1D,EAAEwD,EAAQnB,IAAMlB,EAAG6D,EAAK5D,EAAG6D,GAAMjF,EAC5CyF,EAAK/B,EAAMzD,EAAEuD,EAAQlB,IAAMnB,EAAG8D,EAAK7D,EAAG4D,GAAM/E,EAC3C8D,EAGFA,GADMsB,GAASG,EACN,KAAGC,EAAGH,GACTA,GAASG,EACN,KAAGD,EAAGH,GAEN,IAAGG,EAAGH,KAASI,EAAGH,IAN3BvB,EAAQ,IAAGyB,KAAMC,IAOpBJ,EAAQG,EAAIF,EAAQG,CACvB,CACD1B,GAAQ,GACT,CAEDlG,KAAK8B,OACDyC,OAAO,YACPxC,KAAK,YAAa,aAAYI,KAAKC,MACnCL,KAAK,IAAKmE,GACVtB,KAAK5E,KAAKqE,QAAQQ,MAAMD,KAAK5E,KAAKiF,QAAQJ,KAChD,CAID,SAASgD,IACN,IAAIC,EAAM9H,KAAKC,YAGfD,KAAK6B,UAEL,IAAIkG,EAAK/H,KAAKgC,UAAU,IAAK8F,EAAIrH,IAC7BuH,EAAKhI,KAAKgC,UAAU,IAAK8F,EAAInH,IAC7BmF,EAAK9F,KAAKgC,UAAU,IAAK8F,EAAIrH,GAAKqH,EAAIG,SAAWF,EACjD/B,EAAKhG,KAAKgC,UAAU,IAAK8F,EAAInH,GAAKmH,EAAIG,SAAWD,EAErDhI,KAAK8B,OAAOC,KAAK,YAAa,aAAYgG,KAAMC,MAGhD,IAAIE,EAAKJ,EAAIK,WAAWC,OAAQC,EAAQ,EACpCC,EAAMR,EAAIS,eAAe1F,KAAK+D,GAAI,IAClC4B,EAAK3F,KAAKC,MAAMgD,EAAGjD,KAAKkE,IAAIuB,IAAMG,EAAK5F,KAAKC,MAAMkD,EAAGnD,KAAKoE,IAAIqB,IAElE,QAAShD,EAAI,EAAGA,EAAI4C,EAAI5C,IACrB+C,GAASP,EAAIK,WAAW7C,GAAGoD,OAE9B,QAASpD,EAAI,EAAGA,EAAI4C,EAAI5C,IAAK,CAC1B,IAAIqD,EAAQb,EAAIK,WAAW7C,GACvBjB,EAAU,IAAIC,KAAgB,CAACvC,KAAM4G,IACrC1D,EAAUjF,KAAKkF,cAAcyD,GAEjCL,GAAMK,EAAMD,OAAOL,EAAM,EAAExF,KAAK+D,GAChC,IAAIgC,EAAK/F,KAAKC,MAAMgD,EAAGjD,KAAKkE,IAAIuB,IAAMO,EAAKhG,KAAKC,MAAMkD,EAAGnD,KAAKoE,IAAIqB,IAElEtI,KAAK8B,OACAyC,OAAO,YACPxC,KAAK,IAAM,QAAOyG,KAAMC,KAAM3C,KAAME,WAAY4C,KAAMC,MACtDjE,KAAKP,EAAQQ,MACbD,KAAKK,EAAQJ,MAClB2D,EAAKI,EAAIH,EAAKI,CAChB,CACH,CAID,SAASC,IAEN,IAAIC,EAAM/I,KAAKC,YAEX+I,EADMhJ,KAAKiJ,aACMC,cAAcC,QAAQ,MAAM,EAC7C9E,EAAUrE,KAAK4F,cAAcmD,GAC7B9D,EAAUjF,KAAKkF,cAAc6D,GAGjC/I,KAAK6B,UAEL,IAAI2G,EAAKxI,KAAKgC,UAAU,IAAK+G,EAAIvE,KAC7BoE,EAAK5I,KAAKgC,UAAU,IAAK+G,EAAIrE,KAC7B+D,EAAKzI,KAAKgC,UAAU,IAAK+G,EAAItE,KAC7BoE,EAAK7I,KAAKgC,UAAU,IAAK+G,EAAIpE,KAC7ByE,EAAKvG,KAAKE,IAAIyF,EAAGI,GAAKS,EAAKxG,KAAKE,IAAI0F,EAAGI,GACvCS,EAAKzG,KAAK0G,IAAIX,EAAGJ,GAAKgB,EAAK3G,KAAK0G,IAAId,EAAGI,GAW3C,IARK5D,EAAQQ,UAAYuD,IAAW3E,EAAQ/B,MAAQ,QAEpDtC,KAAK8B,OACAyC,OAAO,YACPxC,KAAK,IAAM,IAAGqH,KAAMC,KAAMC,KAAME,MAAOF,MACvC1E,KAAKP,EAAQQ,MACbD,KAAKK,EAAQJ,MAEdkE,EAAIU,aAAeV,EAAIW,aAAezE,EAAQ0E,WAAY,CAC3D,IAAIC,EAAMb,EAAIW,YAAaG,EAAMd,EAAIW,YACjCI,EAAS,IAAGV,KAAMC,KAAMC,MAAOM,KAAOC,KAAO,EAAED,EAAIN,KAAME,EAAG,EAAEK,MAAQD,KAAOC,KAC7EE,EAAS,IAAGX,EAAGE,KAAMD,EAAGG,MAAOA,MAAOI,KAAOC,KAAOL,EAAG,EAAEK,KAAO,EAAED,EAAIN,MAAOM,KAAOC,KAExF,GAAId,EAAIU,YAAc,EAAG,CAAE,IAAIO,EAAIF,EAAOA,EAAQC,EAAOA,EAAQC,CAAI,CAErEhK,KAAK8B,OAAOyC,OAAO,YACPxC,KAAK,IAAK+H,GACVlF,KAAKK,EAAQJ,MACboF,MAAM,UAAQC,MAAOjF,EAAQ3C,OAAO6H,SAAS,IAAKC,aAE9DpK,KAAK8B,OAAOyC,OAAO,YACdxC,KAAK,IAAKgI,GACVnF,KAAKK,EAAQJ,MACboF,MAAM,UAAQC,MAAOjF,EAAQ3C,OAAO+H,OAAO,IAAKD,YACvD,CACH,CAID,SAASE,IACN,IAAIC,EAASvK,KAAKC,YACduK,EAAM,IAAIC,IAAkBF,GAC5BG,KAAapJ,OAAI,IACjBC,EAAQgJ,EAAOlJ,QAAQqJ,GAG3B1K,KAAK6B,UAEL,IAAIM,EAAInC,KAAKgC,UAAU,IAAKuI,EAAO9J,GAAIc,GACnCa,EAAIpC,KAAKgC,UAAU,IAAKuI,EAAO5J,GAAIY,GACnC2E,EAAOsE,EAAIG,OAAOxI,EAAEC,GAEpB8D,GACDlG,KAAK8B,OAAOyC,OAAO,YACdxC,KAAK,IAAKmE,GACVtB,KAAK4F,EAAI3F,KACnB,CAID,SAAS+F,IAGN5K,KAAK6B,UAEL,IAAIgJ,EAAO7K,KAAKC,YACZuK,EAAM,IAAIC,IAAkBI,GAC5B3E,EAAO,GACPrB,EAAO7E,KAAKqF,mBAEhB,QAASC,EAAI,EAAGA,EAAIuF,EAAKC,KAAMxF,EAC5BY,GAAQsE,EAAIG,OAAO9F,EAAK1C,EAAE0I,EAAKpK,GAAG6E,IAAKT,EAAKzC,EAAEyI,EAAKlK,GAAG2E,KAErDY,GACDlG,KAAK8B,OAAOyC,OAAO,YACdxC,KAAK,IAAKmE,GACVtB,KAAK4F,EAAI3F,KACnB,CAID,SAASkG,EAAYjH,EAAKC,EAAKiH,GAC5B,IAAIhH,EAAU,IAAIiH,KAAYnH,GAC1B3C,EAAO6C,EAAQkH,YACfC,EAAMhK,EAAKoD,OAAO,OAAOxC,KAAK,MAAOgC,EAAIqH,OAAOrJ,KAAK,QAASgC,EAAI1B,QAAU0B,EAAIqH,OAEpF,OAAIJ,GAAOA,EAAI7B,QAAQ,UAAY,EAChCgC,EAAIlB,MAAM,QAAQ,QAAQA,MAAM,SAAS,QACjCe,GAAOA,EAAI7B,QAAQ,WAAa,IACxChI,EAAK8I,MAAM,WAAY,YACvBkB,EAAIpJ,KAAK,QAAS,2FAGrBiC,EAAQqH,gBAEDrH,CACT,8HC/WD,SAASsH,EAAevH,GAErBA,EAAIwH,MAAQC,EAEZ,IAAIC,EAAQ1H,EAAI1B,OAAQqJ,GAAY,EAAOC,EAAU,IACvC,SAAVF,IAAkBA,EAAQ,WAC1B1H,EAAI6H,UAA4C,iBAAzB7H,EAAI6H,SAASA,WACsB,GAAxD7H,EAAI6H,SAASA,SAASzC,QAAQ,0BAC/BuC,GAAY,EAAMC,EAAU,KAC5BF,EAAQ1H,EAAI6H,SAASA,SAASjD,MAAM,MAEpC8C,EAAQ1H,EAAI6H,SAASA,SACrBD,EAAU,MAET5H,EAAI6H,SAASC,kBAAoB9H,EAAI6H,SAASE,SAC/C/H,EAAI6H,SAASE,QAAQC,QAAQC,IAC1B,IAAIC,EAAQ,IAAIC,OAAQ,OAAMF,EAAKG,YAAa,KAC5CC,EAAWrI,EAAI6H,SAASC,iBAAiBG,EAAKK,QAClDZ,EAAQA,EAAMa,QAAQL,EAAQG,EAAW,EAAM,IAAGA,KAAcA,EAAxD,IAKb,aAAcrI,GACfA,EAAIwI,SAASR,QAAQS,IACnBf,EAAQA,EAAMgB,WAAWD,EAAMpB,MAAOoB,EAAMnK,OAApC,GAGboJ,EAAQA,EAAMa,QAAQ,aAAc,cACtBA,QAAQ,kBAAmB,YAC3BA,QAAQ,kBAAmB,YAEzCb,EAAQA,EAAMa,QAAQ,YAAa,kCACrBA,QAAQ,UAAW,6BACnBA,QAAQ,WAAY,8BACpBA,QAAQ,UAAW,6BACnBA,QAAQ,YAAa,+BACrBA,QAAQ,aAAc,gCACtBA,QAAQ,WAAY,eACpBA,QAAQ,gBAAiB,eAEvC,QAASI,EAAI,EAAGA,EAAI3I,EAAI4I,QAASD,EAC/BjB,EAAQA,EAAMgB,WAAWd,EAAUe,EAAI,IAAM,IAAG3I,EAAI6I,YAAYF,OAElEjB,EAAQA,EAAMa,QAAQ,cAAe,YACvBA,QAAQ,cAAe,YACvBA,QAAQ,cAAe,YACvBA,QAAQ,cAAe,YACvBA,QAAQ,cAAe,YACvBA,QAAQ,MAAO,WAC7B,QAAShH,EAAI,EAAGA,EAAI,KAAMA,EACvBmG,EAAQA,EAAMgB,WAAY,KAAInH,IAAM,cAAaA,MAEhDoG,GACDD,EAAQA,EAAMa,QAAQ,UAAU,KACV,QAAlBvI,EAAIrB,WACL+I,EAAQA,EAAMa,QAAQ,UAAU,KAChCvI,EAAI8I,QAAU,IAAIC,SAAS,IAAK,IAAKrB,GAAOsB,KAAKhJ,IAEjDA,EAAI8I,QAAU,IAAIC,SAAS,IAAKrB,GAAOsB,KAAKhJ,IAG/CA,EAAI8I,QADsB,QAAlB9I,EAAIrB,UACE,IAAIoK,SAAS,IAAK,IAAK,UAAYrB,GAAOsB,KAAKhJ,GAE/C,IAAI+I,SAAS,IAAK,UAAYrB,GAAOsB,KAAKhJ,EAC5D,CAQD,MAAMiJ,UAAmB/I,KAGtBgJ,WAAWC,GACR,IAAIC,EAAMnN,KAAKC,YACXkB,EAAOnB,KAAKoB,kBACZgM,EAAQ,EAAGC,EAAQ,EAEvB,GAAIlM,IAAS+L,EAAc,CACxB,IAAII,EAAKnM,EAAKoM,WAAWvN,KAAKwN,SAAUxN,KAAKyN,UAC7CL,EAAQE,EAAGI,WACXL,EAAQC,EAAGK,UACb,CAED,IAAIC,EAAOT,EAAIU,MAAOC,EAAOX,EAAIY,MAAOC,GAAO,EAE3CZ,IAAUC,IACPD,EAAQQ,IAAMA,EAAOR,GACrBC,EAAQS,IAAMA,EAAOT,IAGxBlM,GAAQA,EAAK6M,MAASJ,EAAO,GAAOE,EAAO,IAC5CE,GAAO,EACPJ,EAAO/K,KAAKoL,IAAIL,GAChBE,EAAOjL,KAAKoL,IAAIH,IAGnB,IAAIxG,EAAKzE,KAAKqL,IAAIf,EAAIgB,KAAM,KACxB7K,GAAMwK,EAAOF,IAAStG,EAAK,GAC3B8G,EAAM,GAAIC,GAAU,EAGxB,KAFsBlB,EAAImB,MAAMlG,OAAS,GAAM8E,GAG5C,QAAS5H,EAAI,EAAGA,EAAIgC,EAAIhC,IAAK,CAC1B,IAAInD,EAAIyL,EAAOtI,EAAEhC,EAAIlB,EAAI,EACrB4L,IAAM7L,EAAIU,KAAK0L,IAAIpM,IACvB,IACGC,EAAI+K,EAAIN,QAAQ1K,EAGlB,CAFA,MAAOqM,GACLH,GAAU,CACZ,CAED,GAAIA,EAAS,MAETI,OAAOC,SAAStM,IACjBgM,EAAIO,KAAK,CAAExM,EAAGC,KACnB,CAIJ,IAAKiM,GAAWnB,IAAgBkB,EAAIhG,SAAY+E,EAAImB,MAAMlG,OAAS,EAAI,CAEpEd,EAAK6F,EAAImB,MAAMlG,OAAS,EACxBwF,EAAOT,EAAImB,MAAMhH,GACjBwG,EAAOX,EAAImB,MAAMhH,EAAG,GACpB8G,EAAM,GACN9K,EAAK,EACL,IAAIsL,EAAYzB,EAAI0B,QAAWjB,IAASE,EAAOgB,EAAM,EAEjDF,GACDhB,EAAOT,EAAImB,QAAQhH,GACnBwH,EAAM3B,EAAI0B,OAAOE,OAAOC,QAAQpB,EAAM,IAEtCtK,GAAMwK,EAAOF,IAAStG,EAAG,GAG5B,QAAShC,EAAI,EAAGA,EAAIgC,IAAMhC,EAAG,CAC1B,IAAInD,EAAIyM,EAAYzB,EAAI0B,OAAOE,OAAOE,aAAaH,EAAIxJ,EAAE,GAAKsI,EAAOtK,EAAGgC,EAExE,GAAK8H,IAAUC,IAAYlL,EAAI,EAAEmB,EAAK8J,GAAWjL,EAAI,EAAEmB,EAAK+J,GAAS,SACrE,IAAIjL,EAAI+K,EAAImB,MAAMhJ,GAEdmJ,OAAOC,SAAStM,IAAIgM,EAAIO,KAAK,CAAExM,IAAGC,KACxC,CACH,CAED,OAAOgM,CACT,CAGDc,mBAEG,IAAItB,EAAO,EAAGE,EAAO,EAAGqB,EAAO,EAAGC,EAAO,EACrCC,EAAOrP,KAAKiN,YAAW,GAE3B,MAAIoC,KAAMjH,SAEPwF,EAAOE,EAAOuB,EAAK,GAAGlN,EACtBgN,EAAOC,EAAOC,EAAK,GAAGjN,EAEtBiN,EAAKtD,QAAQ+C,IACVlB,EAAO/K,KAAKE,IAAI+L,EAAI3M,EAAGyL,GACvBE,EAAOjL,KAAKqL,IAAIY,EAAI3M,EAAG2L,GACvBqB,EAAOtM,KAAKE,IAAI+L,EAAI1M,EAAG+M,GACvBC,EAAOvM,KAAKqL,IAAIY,EAAI1M,EAAGgN,EAAhB,GAGNA,EAAO,IAAKA,GAAS,EAAIE,yBACzBH,EAAO,IAAKA,GAAS,EAAIG,0BAGhC,IAAIC,KAAQ5E,UAAO,QACfwC,EAAMnN,KAAKC,YAEfsP,SAAMnE,MAAQ+B,EAAI/B,MAAQ,QAC1BmE,EAAMlN,OAAS8K,EAAI9K,OAEnBkN,EAAMR,OAAOlB,MAAQD,EACrB2B,EAAMR,OAAOhB,MAAQD,EACrByB,EAAMC,OAAO3B,MAAQsB,EACrBI,EAAMC,OAAOzB,MAAQqB,EAErBG,EAAME,SAAWtC,EAAIsC,SACrBF,EAAMG,SAAWvC,EAAIuC,SAEdH,CACT,CAEDI,aAAa5L,GACV,QAAK/D,KAAK4P,gBAAgB7L,KAC1B8L,OAAOC,OAAO9P,KAAKC,YAAa8D,GAChCuH,EAAetL,KAAKC,cACb,EACT,CAGD8P,oBAAoBC,GACjB,IAAIC,GAAU,EAQd,KANKD,IAAQhQ,KAAKqP,MAAQW,EAAIE,WAElBlQ,KAAKqP,KAAKjH,QAAW4H,EAAI7N,EAAInC,KAAKqP,KAAK,GAAGc,KAASH,EAAI7N,EAAInC,KAAKqP,KAAKrP,KAAKqP,KAAKjH,OAAO,GAAG+H,OAClGF,GAAU,GAGTA,EACD,OAAIjQ,KAAK8B,QACN9B,KAAK8B,OAAOsO,OAAO,gBAAgBC,SAC/B,KAGV,IAA6BvB,EAAzB/L,EAAM,IAAQuN,GAAO,EAEzB,QAAQhL,EAAI,EAAGA,EAAItF,KAAKqP,KAAKjH,SAAU9C,EAAG,CACvCwJ,EAAM9O,KAAKqP,KAAK/J,GAChB,IAAIiL,EAAO1N,KAAK0G,IAAIuF,EAAIqB,IAAMH,EAAI7N,GAC9BoO,EAAOxN,IAAOA,EAAMwN,EAAMD,EAAOhL,EACvC,CAEDwJ,EAAM9O,KAAKqP,KAAKiB,GAEhB,IAAIE,EAAOxQ,KAAK8B,OAAOsO,OAAO,gBAC1BK,EAASzQ,KAAKqE,QAAQqM,MAAQ,EAE9BF,EAAK/K,UACN+K,EAAOxQ,KAAK8B,OAAOyC,OAAO,cACPxC,KAAK,QAAQ,eACbkI,MAAM,iBAAiB,QACvBlI,KAAK,IAAK0O,GACV7L,KAAK5E,KAAKqE,QAAQQ,MAClBD,KAAK5E,KAAKiF,QAAQJ,OAExC,IAAIuJ,EAAM,CAAEuC,KAAM3Q,KAAKC,YAAYmL,MACvBwF,MAAO5Q,KAAKC,YAAYoC,OACxBF,EAAG2M,EAAIqB,IACP/N,EAAG0M,EAAI+B,IACPC,OAAQ9Q,KAAKqE,QAAQ/B,MACrByO,OAAQ/Q,KAAKiF,QAAQ+L,eACrBC,MAAO,GACPC,MAAQrO,KAAK0G,IAAIuF,EAAIqB,IAAMH,EAAI7N,GAAKsO,GAAY5N,KAAK0G,IAAIuF,EAAI+B,IAAMb,EAAI5N,GAAKqO,GAExFrC,EAAI+C,QAAUX,EAAKY,SAAS,iBAAmBd,EAC/ClC,EAAIiD,KAAOjD,EAAI8C,MACf9C,EAAIkD,UAAYzO,KAAK0O,KAAMzC,IAAIqB,IAAMH,EAAI7N,EAAI,GAAK2M,IAAI+B,IAAMb,EAAI5N,EAAI,IAEhEgM,EAAI+C,SACLX,EAAKzO,KAAK,KAAM+M,EAAIqB,KACfpO,KAAK,KAAM+M,EAAI+B,KACfO,SAAS,cAAed,GAEhC,IAAIK,EAAO3Q,KAAKwR,gBACZb,GAAMvC,EAAI6C,MAAMtC,KAAKgC,GAEzB,IAAIc,EAAQzR,KAAKoB,kBACbyE,EAAK,MAAG4L,OAAH,EAAGA,EAAOlE,WAAWvN,KAAKwN,SAAUxN,KAAKyN,UAClD,OAAI5H,GACDuI,EAAI6C,MAAMtC,KAAM,OAAM9I,EAAM6L,WAAW,IAAI5C,EAAI3M,UAAU0D,EAAM6L,WAAW,IAAI5C,EAAI1M,MAE9EgM,CACT,CAGDlK,SAEG,IAAIiJ,EAAMnN,KAAKC,YACX0R,EAAK3R,KAAKoB,kBACVd,EAAIqR,EAAGjQ,iBACP+P,EAAQzR,KAAK4R,iBAEjB5R,KAAK6B,SAAQ,GAGb7B,KAAKqP,KAAOrP,KAAKiN,YAAW,GAE5BjN,KAAK4F,cAAc,CAAE7D,KAAMoL,IAC3BnN,KAAKqE,QAAQwN,MAAO,EAEpB7R,KAAKkF,cAAc,CAAEnD,KAAMoL,EAAK2E,KAAM,IACtC9R,KAAKiF,QAAQ4M,MAAO,EAEpB,IAAIhM,EAAQ8L,EAAGpE,WAAWvN,KAAKwN,SAAUxN,KAAKyN,UAG9C,QAAQnI,EAAI,EAAGA,EAAItF,KAAKqP,KAAKjH,SAAU9C,EAAG,CACvC,IAAIwJ,EAAM9O,KAAKqP,KAAK/J,GACpBwJ,EAAIqB,IAAMtK,EAAMsK,IAAIrB,EAAI3M,GACxB2M,EAAI+B,IAAMhL,EAAMgL,IAAI/B,EAAI1M,EAC1B,CAED,GAAIpC,KAAKqP,KAAKjH,OAAS,EAAG,CAEvB,IAAI2J,EAAKzR,EACLmR,EAAMO,MAASP,EAAMO,MAAQ,IAC9BD,EAAKlP,KAAKC,MAAM+C,EAAMgL,IAAI,KACrBkB,EAAKzR,GAAOyR,EAAK,KAAIA,EAAKzR,IAGlC,IAAI4F,KAAO+L,MAAa,SAAUjS,KAAKqP,KAAM0C,EAAI,GAE5C/R,KAAKqE,QAAQoB,SACfzF,KAAK8B,OAAOyC,OAAO,YACdxC,KAAK,QAAS,QACdA,KAAK,IAAKmE,EAAKA,MACf+D,MAAM,OAAQ,QACdrF,KAAK5E,KAAKqE,QAAQQ,MAErB7E,KAAKiF,QAAQQ,SACfzF,KAAK8B,OAAOyC,OAAO,YACdxC,KAAK,QAAS,QACdA,KAAK,IAAKmE,EAAKA,KAAOA,EAAKgM,OAC3BtN,KAAK5E,KAAKiF,QAAQJ,KAC5B,CACH,CAGDsN,cAAcC,EAAKrP,EAAImL,GACpB,GAAa,MAATkE,EAAc,OAAO,EAEzB,IAAIjF,EAAMnN,KAAKC,YAEf,GAAIkN,EAAImB,MAAMlG,OAAS,EAAG,CAGvB,IAAIiK,EAAYlF,EAAIgB,KAIpB,OAAOtL,KAAK0G,IAHD4D,EAAImB,MAAM+D,EAAY,GACtBlF,EAAImB,MAAM+D,EAAY,IAEFA,EAAYxP,KAAK0G,IAAIxG,EAAMmL,EAC5D,CAGD,OAAO,CACT,CAGUoE,YAACxO,EAAKqJ,EAAKnC,GACnB,IAAIhH,EAAU,IAAIgJ,EAAWlJ,EAAKqJ,EAAKnC,GACnCuH,EAAI,IAAIC,KAAYxH,GACpByH,IAAazO,EAAQ4N,iBACrBc,EAAO,OACXH,EAAEI,MAAM,QACJJ,EAAEI,MAAM,QAASD,GAAQ,KAAM1O,EAAQwJ,SAAWiF,GAClDF,EAAEI,MAAM,QAASD,GAAQ,KAAM1O,EAAQyJ,SAAWgF,GAClDF,EAAEI,MAAM,QAAOD,GAAQ,MACvBH,EAAEI,MAAM,QAAOD,GAAQ,MAE3BpH,EAAe6B,GAEf,IAAIyF,EAAKC,QAAQC,SAAQ,GAEzB,QAAKL,GAAYzO,EAAQwJ,UAAYxJ,EAAQyJ,YAC1CmF,EAAKG,SAAgBjP,EAAKE,EAAQkL,mBAAoBwD,IAElDE,EAAG3P,KAAK,KACZe,EAAQgP,qBACRhP,EAAQE,SACDF,GAEZ,EAhSmC,oEC3EvC,MAAMiP,UAAsBC,gBAIzBC,WAAWxB,EAAIyB,GAEZ,KAAKzB,EAAGnQ,QAAWmQ,EAAGxB,KAAQwB,EAAGd,KAAQc,EAAG0B,KAAQ1B,EAAG2B,UACpD,OAAOC,QAAQtF,IAAI,0CAEtB,GAAI0D,EAAG6B,WAAa7B,EAAG8B,YAChBzT,KAAK0T,QAAQC,MAAQhC,EAAG6B,WAAexT,KAAK0T,QAAQC,MAAQhC,EAAG8B,WAAY,OAElF,IAAIG,EAAW5T,KAAK6T,aAAa,KAC7B1H,EAAQ,EAAG2H,EAAOF,EAASxL,OAAO,EAEtC,GAAIuJ,EAAGoC,WAAapC,EAAGqC,UAAW,CAC/B,KAAQ7H,EAAQ2H,GAAUF,EAASzH,GAAOhK,EAAIwP,EAAGoC,WAAY5H,IAC7D,KAAQA,EAAQ2H,GAAUF,EAASE,GAAM3R,EAAIwP,EAAGqC,WAAYF,GAC9D,CAED,GAAI3H,GAAS2H,EAAM,OAEnB,IAAIG,EAAO,GAAI9D,EAAMwB,EAAGxB,IAAInQ,KAAK0T,QAAQC,OACrCO,EAAKN,EAASzH,GAElB,QAAS7G,EAAI6G,EAAQ,EAAG7G,GAAKwO,IAAQxO,EAAG,CACrC,IAAI6O,EAAKP,EAAStO,GAClB2O,EAAKtF,KAAKwB,EAAKwB,EAAGd,IAAIqD,EAAG/R,GAAIwP,EAAG0B,IAAIa,EAAG9R,GAC7B+N,EAAKwB,EAAGd,IAAIsD,EAAGhS,GAAIwP,EAAG0B,IAAIc,EAAG/R,IACvC8R,EAAKC,CACP,CAED,IAAIlD,KAAQmD,MAAmBH,KAAMI,MAAqBrU,KAAMoT,IAEhEzB,EAAG2B,SAASgB,IAAIrD,GAEhBU,EAAG4C,SAAS,IACd,CAIDC,gBACG,IAAIjF,EAAQvP,KAAKyU,kBACjB,OAAO1B,kBAAgB/S,KAAK0U,SAAUnF,EAAOvP,KAAK0T,QAAQiB,KAC5D,CAEUrC,YAACxO,EAAKsP,EAAOpI,GACrB,OAAOiI,EAAc2B,WAAW,IAAI3B,EAAcnP,EAAKsP,GAAQpI,EACjE,EAhDwC","names":["drawText","text","this","getObject","pp","getPadPainter","w","getPadWidth","h","getPadHeight","pos_x","fX","pos_y","fY","tcolor","getColor","fTextColor","use_frame","fact","textsize","fTextSize","main","getFramePainter","TestBit","BIT","isndc","mode3d","getFrameWidth","getFrameHeight","getRootPad","fTextAlign","createG","draw_g","attr","axisToSvg","arg","align","x","y","fTitle","color","latex","fTextAngle","rotate","_typename","startTextDrawing","fTextFont","Math","round","min","finishTextDrawing","then","isBatchMode","pos_dx","pos_dy","moveDrag","dx","dy","moveEnd","not_changed","svgToAxis","submitCanvExec","addMoveHandler","drawTLine","dom","obj","painter","ObjectPainter","redraw","kLineNDC","line","lineatt","TAttLineHandler","append","fX1","fY1","fX2","fY2","call","func","ensureTCanvas","drawPolyLine","polyline","fillatt","createAttFill","kPolyLineNDC","cmd","getAxisToSvgFunc","n","fLastPoint","setSolidColor","empty","drawEllipse","ellipse","createAttLine","funcs","rx","fR1","ry","fR2","path","closed_ellipse","fPhimin","fPhimax","rx1","ry2","ry1","rx2","large_arc","a1","PI","a2","dx1","cos","dy1","sin","fTheta","ct","st","phi1","np","dphi","lastx","lasty","angle","px","py","drawPie","pie","xc","yc","fRadius","nb","fPieSlices","length","total","af","fAngularOffset","x1","y1","fValue","slice","x2","y2","drawBox","box","draw_line","getDrawOpt","toUpperCase","indexOf","xx","yy","ww","abs","hh","fBorderMode","fBorderSize","hasColor","pww","phh","side1","side2","s","style","d3_rgb","brighter","formatHex","darker","drawMarker","marker","att","TAttMarkerHandler","kMarkerNDC","create","drawPolyMarker","poly","fN","drawJSImage","opt","BasePainter","selectDom","img","fName","setTopPainter","proivdeEvalPar","_math","jsroot_math","_func","isformula","pprefix","fFormula","fClingParameters","fParams","forEach","pair","regex","RegExp","first","parvalue","second","replace","formulas","entry","replaceAll","i","fNpar","GetParValue","evalPar","Function","bind","TF1Painter","createBins","ignore_zoom","tf1","gxmin","gxmax","gr","getGrFuncs","second_x","second_y","scale_xmin","scale_xmax","xmin","fXmin","xmax","fXmax","logx","log","max","fNpx","res","iserror","fSave","exp","err","Number","isFinite","push","use_histo","$histo","bin","fXaxis","FindBin","GetBinCenter","createDummyHisto","ymin","ymax","bins","gStyle","histo","fYaxis","fMinimum","fMaximum","updateObject","matchObjectType","Object","assign","processTooltipEvent","pnt","cleanup","disabled","grx","select","remove","best","dist","gbin","radius","width","name","title","gry","color1","color2","getFillColor","lines","exact","changed","property","menu","menu_dist","sqrt","getObjectHint","pmain","axisAsText","fp","getMainPainter","used","kind","h0","hmin","buildSvgPath","close","canZoomInside","axis","nb_points","static","d","DrawOptions","has_main","aopt","check","pr","Promise","resolve","TH1Painter","addToPadPrimitives","TGraphPainter","TGraphPainter2D","drawBins3D","graph","grz","toplevel","console","zoom_xmin","zoom_xmax","options","pos3d","drawbins","optimizeBins","last","zoom_ymin","zoom_ymax","pnts","p0","p1","createLineSegments","create3DLineMaterial","add","render3D","drawAxisHisto","createHistogram","getDom","Axis","_drawGraph"],"sourceRoot":"webpack:///","sources":["../../node_modules/jsroot/modules/draw/more.mjs","../../node_modules/jsroot/modules/hist/TF1Painter.mjs","../../node_modules/jsroot/modules/hist/TGraphPainter.mjs"],"sourcesContent":["import { BIT, isBatchMode } from '../core.mjs';\nimport { rgb as d3_rgb } from '../d3.mjs';\nimport { BasePainter } from '../base/BasePainter.mjs';\nimport { ObjectPainter } from '../base/ObjectPainter.mjs';\nimport { TAttMarkerHandler } from '../base/TAttMarkerHandler.mjs';\nimport { TAttLineHandler } from '../base/TAttLineHandler.mjs';\nimport { ensureTCanvas } from '../gpad/TCanvasPainter.mjs';\nimport { addMoveHandler } from '../gui/utils.mjs';\n\n\n/** @summary Draw TText\n  * @private */\nfunction drawText() {\n   let text = this.getObject(),\n       pp = this.getPadPainter(),\n       w = pp.getPadWidth(),\n       h = pp.getPadHeight(),\n       pos_x = text.fX, pos_y = text.fY,\n       tcolor = this.getColor(text.fTextColor),\n       use_frame = false,\n       fact = 1., textsize = text.fTextSize || 0.05,\n       main = this.getFramePainter();\n\n   if (text.TestBit(BIT(14))) {\n      // NDC coordinates\n      this.isndc = true;\n   } else if (main && !main.mode3d) {\n      // frame coordiantes\n      w = main.getFrameWidth();\n      h = main.getFrameHeight();\n      use_frame = \"upper_layer\";\n   } else if (pp.getRootPad(true)) {\n      // force pad coordiantes\n   } else {\n      // place in the middle\n      this.isndc = true;\n      pos_x = pos_y = 0.5;\n      text.fTextAlign = 22;\n      if (!tcolor) tcolor = 'black';\n   }\n\n   this.createG(use_frame);\n\n   this.draw_g.attr(\"transform\", null); // remove transofrm from interactive changes\n\n   this.pos_x = this.axisToSvg(\"x\", pos_x, this.isndc);\n   this.pos_y = this.axisToSvg(\"y\", pos_y, this.isndc);\n\n   let arg = { align: text.fTextAlign, x: this.pos_x, y: this.pos_y, text: text.fTitle, color: tcolor, latex: 0 };\n\n   if (text.fTextAngle) arg.rotate = -text.fTextAngle;\n\n   if (text._typename == 'TLatex') { arg.latex = 1; fact = 0.9; } else\n   if (text._typename == 'TMathText') { arg.latex = 2; fact = 0.8; }\n\n   this.startTextDrawing(text.fTextFont, Math.round((textsize>1) ? textsize : textsize*Math.min(w,h)*fact));\n\n   this.drawText(arg);\n\n   return this.finishTextDrawing().then(() => {\n      if (isBatchMode()) return this;\n\n      this.pos_dx = this.pos_dy = 0;\n\n      if (!this.moveDrag)\n         this.moveDrag = function(dx,dy) {\n            this.pos_dx += dx;\n            this.pos_dy += dy;\n            this.draw_g.attr(\"transform\", `translate(${this.pos_dx},${this.pos_dy})`);\n        }\n\n      if (!this.moveEnd)\n         this.moveEnd = function(not_changed) {\n            if (not_changed) return;\n            let text = this.getObject();\n            text.fX = this.svgToAxis(\"x\", this.pos_x + this.pos_dx, this.isndc),\n            text.fY = this.svgToAxis(\"y\", this.pos_y + this.pos_dy, this.isndc);\n            this.submitCanvExec(`SetX(${text.fX});;SetY(${text.fY});;`);\n         }\n\n      addMoveHandler(this);\n\n      return this;\n   });\n}\n\n/** @summary Draw TLine\n  * @private */\nfunction drawTLine(dom, obj) {\n\n   let painter = new ObjectPainter(dom, obj);\n\n   painter.redraw = function() {\n      const kLineNDC = BIT(14),\n            line = this.getObject(),\n            lineatt = new TAttLineHandler(line),\n            isndc = line.TestBit(kLineNDC);\n\n      // create svg:g container for line drawing\n      this.createG();\n\n      this.draw_g\n          .append(\"svg:path\")\n          .attr(\"d\", `M${this.axisToSvg(\"x\", line.fX1, isndc)},${this.axisToSvg(\"y\", line.fY1, isndc)}L${this.axisToSvg(\"x\", line.fX2, isndc)},${this.axisToSvg(\"y\", line.fY2, isndc)}`)\n          .call(lineatt.func);\n\n      return this;\n   }\n\n   return ensureTCanvas(painter, false).then(() => painter.redraw());\n}\n\n/** @summary Draw TPolyLine\n  * @private */\nfunction drawPolyLine() {\n\n   // create svg:g container for polyline drawing\n   this.createG();\n\n   let polyline = this.getObject(),\n       lineatt = new TAttLineHandler(polyline),\n       fillatt = this.createAttFill(polyline),\n       kPolyLineNDC = BIT(14),\n       isndc = polyline.TestBit(kPolyLineNDC),\n       cmd = \"\", func = this.getAxisToSvgFunc(isndc);\n\n   for (let n = 0; n <= polyline.fLastPoint; ++n)\n      cmd += ((n > 0) ? \"L\" : \"M\") + func.x(polyline.fX[n]) + \",\" + func.y(polyline.fY[n]);\n\n   if (polyline._typename != \"TPolyLine\") fillatt.setSolidColor(\"none\");\n\n   if (!fillatt.empty()) cmd+=\"Z\";\n\n   this.draw_g\n       .append(\"svg:path\")\n       .attr(\"d\", cmd)\n       .call(lineatt.func)\n       .call(fillatt.func);\n}\n\n/** @summary Draw TEllipse\n  * @private */\nfunction drawEllipse() {\n\n   let ellipse = this.getObject();\n\n   this.createAttLine({ attr: ellipse });\n   this.createAttFill({ attr: ellipse });\n\n   // create svg:g container for ellipse drawing\n   this.createG();\n\n   let funcs = this.getAxisToSvgFunc(),\n       x = funcs.x(ellipse.fX1),\n       y = funcs.y(ellipse.fY1),\n       rx = funcs.x(ellipse.fX1 + ellipse.fR1) - x,\n       ry = y - funcs.y(ellipse.fY1 + ellipse.fR2),\n       path = \"\", closed_ellipse = (ellipse.fPhimin == 0) && (ellipse.fPhimax == 360);\n\n   // handle same as ellipse with equal radius\n   if ((ellipse._typename == \"TCrown\") && (ellipse.fR1 <= 0))\n      rx = funcs.x(ellipse.fX1 + ellipse.fR2) - x;\n\n   if ((ellipse._typename == \"TCrown\") && (ellipse.fR1 > 0)) {\n      let rx1 = rx, ry2 = ry,\n          ry1 = y - funcs.y(ellipse.fY1 + ellipse.fR1),\n          rx2 = funcs.x(ellipse.fX1 + ellipse.fR2) - x;\n\n      if (closed_ellipse) {\n         path = `M${-rx1},0A${rx1},${ry1},0,1,0,${rx1},0A${rx1},${ry1},0,1,0,${-rx1},0` +\n                `M${-rx2},0A${rx2},${ry2},0,1,0,${rx2},0A${rx2},${ry2},0,1,0,${-rx2},0`;\n      } else {\n         let large_arc = (ellipse.fPhimax-ellipse.fPhimin>=180) ? 1 : 0,\n             a1 = ellipse.fPhimin*Math.PI/180, a2 = ellipse.fPhimax*Math.PI/180,\n             dx1 = Math.round(rx1*Math.cos(a1)), dy1 = Math.round(ry1*Math.sin(a1)),\n             dx2 = Math.round(rx1*Math.cos(a2)), dy2 = Math.round(ry1*Math.sin(a2)),\n             dx3 = Math.round(rx2*Math.cos(a1)), dy3 = Math.round(ry2*Math.sin(a1)),\n             dx4 = Math.round(rx2*Math.cos(a2)), dy4 = Math.round(ry2*Math.sin(a2));\n\n         path = `M${dx2},${dy2}A${rx1},${ry1},0,${large_arc},0,${dx1},${dy1}` +\n                `L${dx3},${dy3}A${rx2},${ry2},0,${large_arc},1,${dx4},${dy4}Z`;\n      }\n   } else if (ellipse.fTheta == 0) {\n      if (closed_ellipse) {\n         path = `M${-rx},0A${rx},${ry},0,1,0,${rx},0A${rx},${ry},0,1,0,${-rx},0Z`;\n      } else {\n         let x1 = Math.round(rx * Math.cos(ellipse.fPhimin*Math.PI/180)),\n             y1 = Math.round(ry * Math.sin(ellipse.fPhimin*Math.PI/180)),\n             x2 = Math.round(rx * Math.cos(ellipse.fPhimax*Math.PI/180)),\n             y2 = Math.round(ry * Math.sin(ellipse.fPhimax*Math.PI/180));\n         path = `M0,0L${x1},${y1}A${rx},${ry},0,1,1,${x2},${y2}Z`;\n      }\n   } else {\n     let ct = Math.cos(ellipse.fTheta*Math.PI/180),\n         st = Math.sin(ellipse.fTheta*Math.PI/180),\n         phi1 = ellipse.fPhimin*Math.PI/180,\n         phi2 = ellipse.fPhimax*Math.PI/180,\n         np = 200,\n         dphi = (phi2-phi1) / (np - (closed_ellipse ? 0 : 1)),\n         lastx = 0, lasty = 0;\n     if (!closed_ellipse) path = \"M0,0\";\n     for (let n = 0; n < np; ++n) {\n         let angle = phi1 + n*dphi,\n             dx = ellipse.fR1 * Math.cos(angle),\n             dy = ellipse.fR2 * Math.sin(angle),\n             px = funcs.x(ellipse.fX1 + dx*ct - dy*st) - x,\n             py = funcs.y(ellipse.fY1 + dx*st + dy*ct) - y;\n         if (!path)\n            path = `M${px},${py}`;\n         else if (lastx == px)\n            path += `v${py-lasty}`;\n         else if (lasty == py)\n            path += `h${px-lastx}`;\n         else\n            path += `l${px-lastx},${py-lasty}`;\n         lastx = px; lasty = py;\n     }\n     path += \"Z\";\n   }\n\n   this.draw_g\n      .append(\"svg:path\")\n      .attr(\"transform\",`translate(${x},${y})`)\n      .attr(\"d\", path)\n      .call(this.lineatt.func).call(this.fillatt.func);\n}\n\n/** @summary Draw TPie\n  * @private */\nfunction drawPie() {\n   let pie = this.getObject();\n\n   // create svg:g container for ellipse drawing\n   this.createG();\n\n   let xc = this.axisToSvg(\"x\", pie.fX),\n       yc = this.axisToSvg(\"y\", pie.fY),\n       rx = this.axisToSvg(\"x\", pie.fX + pie.fRadius) - xc,\n       ry = this.axisToSvg(\"y\", pie.fY + pie.fRadius) - yc;\n\n   this.draw_g.attr(\"transform\",`translate(${xc},${yc})`);\n\n   // Draw the slices\n   let nb = pie.fPieSlices.length, total = 0,\n       af = (pie.fAngularOffset*Math.PI)/180,\n       x1 = Math.round(rx*Math.cos(af)), y1 = Math.round(ry*Math.sin(af));\n\n   for (let n = 0; n < nb; n++)\n      total += pie.fPieSlices[n].fValue;\n\n   for (let n = 0; n < nb; n++) {\n      let slice = pie.fPieSlices[n],\n          lineatt = new TAttLineHandler({attr: slice}),\n          fillatt = this.createAttFill(slice);\n\n      af += slice.fValue/total*2*Math.PI;\n      let x2 = Math.round(rx*Math.cos(af)), y2 = Math.round(ry*Math.sin(af));\n\n      this.draw_g\n          .append(\"svg:path\")\n          .attr(\"d\", `M0,0L${x1},${y1}A${rx},${ry},0,0,0,${x2},${y2}z`)\n          .call(lineatt.func)\n          .call(fillatt.func);\n      x1 = x2; y1 = y2;\n   }\n}\n\n/** @summary Draw TBox\n  * @private */\nfunction drawBox() {\n\n   let box = this.getObject(),\n       opt = this.getDrawOpt(),\n       draw_line = (opt.toUpperCase().indexOf(\"L\")>=0),\n       lineatt = this.createAttLine(box),\n       fillatt = this.createAttFill(box);\n\n   // create svg:g container for box drawing\n   this.createG();\n\n   let x1 = this.axisToSvg(\"x\", box.fX1),\n       x2 = this.axisToSvg(\"x\", box.fX2),\n       y1 = this.axisToSvg(\"y\", box.fY1),\n       y2 = this.axisToSvg(\"y\", box.fY2),\n       xx = Math.min(x1,x2), yy = Math.min(y1,y2),\n       ww = Math.abs(x2-x1), hh = Math.abs(y1-y2);\n\n   // if box filled, contour line drawn only with \"L\" draw option:\n   if (!fillatt.empty() && !draw_line) lineatt.color = \"none\";\n\n   this.draw_g\n       .append(\"svg:path\")\n       .attr(\"d\", `M${xx},${yy}h${ww}v${hh}h${-ww}z`)\n       .call(lineatt.func)\n       .call(fillatt.func);\n\n   if (box.fBorderMode && box.fBorderSize && fillatt.hasColor()) {\n      let pww = box.fBorderSize, phh = box.fBorderSize,\n          side1 = `M${xx},${yy}h${ww}l${-pww},${phh}h${2*pww-ww}v${hh-2*phh}l${-pww},${phh}z`,\n          side2 = `M${xx+ww},${yy+hh}v${-hh}l${-pww},${phh}v${hh-2*phh}h${2*pww-ww}l${-pww},${phh}z`;\n\n      if (box.fBorderMode < 0) { let s = side1; side1 = side2; side2 = s; }\n\n      this.draw_g.append(\"svg:path\")\n                 .attr(\"d\", side1)\n                 .call(fillatt.func)\n                 .style(\"fill\", d3_rgb(fillatt.color).brighter(0.5).formatHex());\n\n      this.draw_g.append(\"svg:path\")\n          .attr(\"d\", side2)\n          .call(fillatt.func)\n          .style(\"fill\", d3_rgb(fillatt.color).darker(0.5).formatHex());\n   }\n}\n\n/** @summary Draw TMarker\n  * @private */\nfunction drawMarker() {\n   let marker = this.getObject(),\n       att = new TAttMarkerHandler(marker),\n       kMarkerNDC = BIT(14),\n       isndc = marker.TestBit(kMarkerNDC);\n\n   // create svg:g container for box drawing\n   this.createG();\n\n   let x = this.axisToSvg(\"x\", marker.fX, isndc),\n       y = this.axisToSvg(\"y\", marker.fY, isndc),\n       path = att.create(x,y);\n\n   if (path)\n      this.draw_g.append(\"svg:path\")\n          .attr(\"d\", path)\n          .call(att.func);\n}\n\n/** @summary Draw TPolyMarker\n  * @private */\nfunction drawPolyMarker() {\n\n   // create svg:g container for box drawing\n   this.createG();\n\n   let poly = this.getObject(),\n       att = new TAttMarkerHandler(poly),\n       path = \"\",\n       func = this.getAxisToSvgFunc();\n\n   for (let n = 0; n < poly.fN; ++n)\n      path += att.create(func.x(poly.fX[n]), func.y(poly.fY[n]));\n\n   if (path)\n      this.draw_g.append(\"svg:path\")\n          .attr(\"d\", path)\n          .call(att.func);\n}\n\n/** @summary Draw JS image\n  * @private */\nfunction drawJSImage(dom, obj, opt) {\n   let painter = new BasePainter(dom),\n       main = painter.selectDom(),\n       img = main.append(\"img\").attr(\"src\", obj.fName).attr(\"title\", obj.fTitle || obj.fName);\n\n   if (opt && opt.indexOf(\"scale\") >= 0) {\n      img.style(\"width\",\"100%\").style(\"height\",\"100%\");\n   } else if (opt && opt.indexOf(\"center\") >= 0) {\n      main.style(\"position\", \"relative\");\n      img.attr(\"style\", \"margin: 0; position: absolute;  top: 50%; left: 50%; transform: translate(-50%, -50%);\");\n   }\n\n   painter.setTopPainter();\n\n   return painter;\n}\n\nexport { drawText, drawTLine, drawPolyLine, drawEllipse, drawPie, drawBox,\n         drawMarker, drawPolyMarker, drawJSImage };\n","import { create, gStyle } from '../core.mjs';\nimport { DrawOptions, buildSvgPath } from '../base/BasePainter.mjs';\nimport { ObjectPainter } from '../base/ObjectPainter.mjs';\nimport { TH1Painter } from '../hist2d/TH1Painter.mjs';\nimport * as jsroot_math from '../base/math.mjs';\n\n\nfunction proivdeEvalPar(obj) {\n\n   obj._math = jsroot_math;\n\n   let _func = obj.fTitle, isformula = false, pprefix = \"[\";\n   if (_func === \"gaus\") _func = \"gaus(0)\";\n   if (obj.fFormula && typeof obj.fFormula.fFormula == \"string\") {\n     if (obj.fFormula.fFormula.indexOf(\"[](double*x,double*p)\")==0) {\n        isformula = true; pprefix = \"p[\";\n        _func = obj.fFormula.fFormula.slice(21);\n     } else {\n        _func = obj.fFormula.fFormula;\n        pprefix = \"[p\";\n     }\n     if (obj.fFormula.fClingParameters && obj.fFormula.fParams)\n        obj.fFormula.fParams.forEach(pair => {\n           let regex = new RegExp(`(\\\\[${pair.first}\\\\])`, 'g'),\n               parvalue = obj.fFormula.fClingParameters[pair.second];\n           _func = _func.replace(regex, (parvalue < 0) ? `(${parvalue})` : parvalue);\n        });\n\n  }\n\n  if ('formulas' in obj)\n     obj.formulas.forEach(entry => {\n       _func = _func.replaceAll(entry.fName, entry.fTitle);\n     });\n\n  _func = _func.replace(/\\b(abs)\\b/g, 'TMath::Abs')\n               .replace(/\\b(TMath::Exp)/g, 'Math.exp')\n               .replace(/\\b(TMath::Abs)/g, 'Math.abs');\n\n  _func = _func.replace(/xygaus\\(/g, 'this._math.gausxy(this, x, y, ')\n               .replace(/gaus\\(/g, 'this._math.gaus(this, x, ')\n               .replace(/gausn\\(/g, 'this._math.gausn(this, x, ')\n               .replace(/expo\\(/g, 'this._math.expo(this, x, ')\n               .replace(/landau\\(/g, 'this._math.landau(this, x, ')\n               .replace(/landaun\\(/g, 'this._math.landaun(this, x, ')\n               .replace(/TMath::/g, 'this._math.')\n               .replace(/ROOT::Math::/g, 'this._math.');\n\n  for (let i = 0; i < obj.fNpar; ++i)\n    _func = _func.replaceAll(pprefix + i + \"]\", `(${obj.GetParValue(i)})`);\n\n  _func = _func.replace(/\\b(sin)\\b/gi, 'Math.sin')\n               .replace(/\\b(cos)\\b/gi, 'Math.cos')\n               .replace(/\\b(tan)\\b/gi, 'Math.tan')\n               .replace(/\\b(exp)\\b/gi, 'Math.exp')\n               .replace(/\\b(pow)\\b/gi, 'Math.pow')\n               .replace(/pi/g, 'Math.PI');\n  for (let n = 2; n < 10; ++n)\n     _func = _func.replaceAll(`x^${n}`, `Math.pow(x,${n})`);\n\n  if (isformula) {\n     _func = _func.replace(/x\\[0\\]/g,\"x\");\n     if (obj._typename === \"TF2\") {\n        _func = _func.replace(/x\\[1\\]/g,\"y\");\n        obj.evalPar = new Function(\"x\", \"y\", _func).bind(obj);\n     } else {\n        obj.evalPar = new Function(\"x\", _func).bind(obj);\n     }\n  } else if (obj._typename === \"TF2\")\n     obj.evalPar = new Function(\"x\", \"y\", \"return \" + _func).bind(obj);\n  else\n     obj.evalPar = new Function(\"x\", \"return \" + _func).bind(obj);\n}\n\n/**\n  * @summary Painter for TF1 object\n  *\n  * @private\n  */\n\nclass TF1Painter extends ObjectPainter {\n\n   /** @summary Create bins for TF1 drawing */\n   createBins(ignore_zoom) {\n      let tf1 = this.getObject(),\n          main = this.getFramePainter(),\n          gxmin = 0, gxmax = 0;\n\n      if (main && !ignore_zoom)  {\n         let gr = main.getGrFuncs(this.second_x, this.second_y);\n         gxmin = gr.scale_xmin;\n         gxmax = gr.scale_xmax;\n      }\n\n      let xmin = tf1.fXmin, xmax = tf1.fXmax, logx = false;\n\n      if (gxmin !== gxmax) {\n         if (gxmin > xmin) xmin = gxmin;\n         if (gxmax < xmax) xmax = gxmax;\n      }\n\n      if (main && main.logx && (xmin > 0) && (xmax > 0)) {\n         logx = true;\n         xmin = Math.log(xmin);\n         xmax = Math.log(xmax);\n      }\n\n      let np = Math.max(tf1.fNpx, 101),\n          dx = (xmax - xmin) / (np - 1),\n          res = [], iserror = false,\n          force_use_save = (tf1.fSave.length > 3) && ignore_zoom;\n\n      if (!force_use_save)\n         for (let n = 0; n < np; n++) {\n            let x = xmin + n*dx, y = 0;\n            if (logx) x = Math.exp(x);\n            try {\n               y = tf1.evalPar(x);\n            } catch(err) {\n               iserror = true;\n            }\n\n            if (iserror) break;\n\n            if (Number.isFinite(y))\n               res.push({ x, y });\n         }\n\n      // in the case there were points have saved and we cannot calculate function\n      // if we don't have the user's function\n      if ((iserror || ignore_zoom || !res.length) && (tf1.fSave.length > 3)) {\n\n         np = tf1.fSave.length - 2;\n         xmin = tf1.fSave[np];\n         xmax = tf1.fSave[np+1];\n         res = [];\n         dx = 0;\n         let use_histo = tf1.$histo && (xmin === xmax), bin = 0;\n\n         if (use_histo) {\n            xmin = tf1.fSave[--np];\n            bin = tf1.$histo.fXaxis.FindBin(xmin, 0);\n         } else {\n            dx = (xmax - xmin) / (np-1);\n         }\n\n         for (let n = 0; n < np; ++n) {\n            let x = use_histo ? tf1.$histo.fXaxis.GetBinCenter(bin+n+1) : xmin + dx*n;\n            // check if points need to be displayed at all, keep at least 4-5 points for Bezier curves\n            if ((gxmin !== gxmax) && ((x + 2*dx < gxmin) || (x - 2*dx > gxmax))) continue;\n            let y = tf1.fSave[n];\n\n            if (Number.isFinite(y)) res.push({ x, y });\n         }\n      }\n\n      return res;\n   }\n\n   /** @summary Create histogram for axes drawing */\n   createDummyHisto() {\n\n      let xmin = 0, xmax = 1, ymin = 0, ymax = 1,\n          bins = this.createBins(true);\n\n      if (bins?.length) {\n\n         xmin = xmax = bins[0].x;\n         ymin = ymax = bins[0].y;\n\n         bins.forEach(bin => {\n            xmin = Math.min(bin.x, xmin);\n            xmax = Math.max(bin.x, xmax);\n            ymin = Math.min(bin.y, ymin);\n            ymax = Math.max(bin.y, ymax);\n         });\n\n         if (ymax > 0.0) ymax *= (1 + gStyle.fHistTopMargin);\n         if (ymin < 0.0) ymin *= (1 + gStyle.fHistTopMargin);\n      }\n\n      let histo = create(\"TH1I\"),\n          tf1 = this.getObject();\n\n      histo.fName = tf1.fName + \"_hist\";\n      histo.fTitle = tf1.fTitle;\n\n      histo.fXaxis.fXmin = xmin;\n      histo.fXaxis.fXmax = xmax;\n      histo.fYaxis.fXmin = ymin;\n      histo.fYaxis.fXmax = ymax;\n\n      histo.fMinimum = tf1.fMinimum;\n      histo.fMaximum = tf1.fMaximum;\n\n      return histo;\n   }\n\n   updateObject(obj /*, opt */) {\n      if (!this.matchObjectType(obj)) return false;\n      Object.assign(this.getObject(), obj);\n      proivdeEvalPar(this.getObject());\n      return true;\n   }\n\n   /** @summary Process tooltip event */\n   processTooltipEvent(pnt) {\n      let cleanup = false;\n\n      if (!pnt || !this.bins || pnt.disabled) {\n         cleanup = true;\n      } else if (!this.bins.length || (pnt.x < this.bins[0].grx) || (pnt.x > this.bins[this.bins.length-1].grx)) {\n         cleanup = true;\n      }\n\n      if (cleanup) {\n         if (this.draw_g)\n            this.draw_g.select(\".tooltip_bin\").remove();\n         return null;\n      }\n\n      let min = 100000, best = -1, bin;\n\n      for(let n = 0; n < this.bins.length; ++n) {\n         bin = this.bins[n];\n         let dist = Math.abs(bin.grx - pnt.x);\n         if (dist < min) { min = dist; best = n; }\n      }\n\n      bin = this.bins[best];\n\n      let gbin = this.draw_g.select(\".tooltip_bin\"),\n          radius = this.lineatt.width + 3;\n\n      if (gbin.empty())\n         gbin = this.draw_g.append(\"svg:circle\")\n                           .attr(\"class\",\"tooltip_bin\")\n                           .style(\"pointer-events\",\"none\")\n                           .attr(\"r\", radius)\n                           .call(this.lineatt.func)\n                           .call(this.fillatt.func);\n\n      let res = { name: this.getObject().fName,\n                  title: this.getObject().fTitle,\n                  x: bin.grx,\n                  y: bin.gry,\n                  color1: this.lineatt.color,\n                  color2: this.fillatt.getFillColor(),\n                  lines: [],\n                  exact: (Math.abs(bin.grx - pnt.x) < radius) && (Math.abs(bin.gry - pnt.y) < radius) };\n\n      res.changed = gbin.property(\"current_bin\") !== best;\n      res.menu = res.exact;\n      res.menu_dist = Math.sqrt((bin.grx - pnt.x)**2 + (bin.gry - pnt.y)**2);\n\n      if (res.changed)\n         gbin.attr(\"cx\", bin.grx)\n             .attr(\"cy\", bin.gry)\n             .property(\"current_bin\", best);\n\n      let name = this.getObjectHint();\n      if (name) res.lines.push(name);\n\n      let pmain = this.getFramePainter(),\n          funcs = pmain?.getGrFuncs(this.second_x, this.second_y);\n      if (funcs)\n         res.lines.push(`x = ${funcs.axisAsText(\"x\",bin.x)} y = ${funcs.axisAsText(\"y\",bin.y)}`);\n\n      return res;\n   }\n\n   /** @summary Redraw function */\n   redraw() {\n\n      let tf1 = this.getObject(),\n          fp = this.getFramePainter(),\n          h = fp.getFrameHeight(),\n          pmain = this.getMainPainter();\n\n      this.createG(true);\n\n      // recalculate drawing bins when necessary\n      this.bins = this.createBins(false);\n\n      this.createAttLine({ attr: tf1 });\n      this.lineatt.used = false;\n\n      this.createAttFill({ attr: tf1, kind: 1 });\n      this.fillatt.used = false;\n\n      let funcs = fp.getGrFuncs(this.second_x, this.second_y);\n\n      // first calculate graphical coordinates\n      for(let n = 0; n < this.bins.length; ++n) {\n         let bin = this.bins[n];\n         bin.grx = funcs.grx(bin.x);\n         bin.gry = funcs.gry(bin.y);\n      }\n\n      if (this.bins.length > 2) {\n\n         let h0 = h;  // use maximal frame height for filling\n         if (pmain.hmin && (pmain.hmin >= 0)) {\n            h0 = Math.round(funcs.gry(0));\n            if ((h0 > h) || (h0 < 0)) h0 = h;\n         }\n\n         let path = buildSvgPath(\"bezier\", this.bins, h0, 2);\n\n         if (!this.lineatt.empty())\n            this.draw_g.append(\"svg:path\")\n                .attr(\"class\", \"line\")\n                .attr(\"d\", path.path)\n                .style(\"fill\", \"none\")\n                .call(this.lineatt.func);\n\n         if (!this.fillatt.empty())\n            this.draw_g.append(\"svg:path\")\n                .attr(\"class\", \"area\")\n                .attr(\"d\", path.path + path.close)\n                .call(this.fillatt.func);\n      }\n   }\n\n   /** @summary Checks if it makes sense to zoom inside specified axis range */\n   canZoomInside(axis,min,max) {\n      if (axis !== \"x\") return false;\n\n      let tf1 = this.getObject();\n\n      if (tf1.fSave.length > 0) {\n         // in the case where the points have been saved, useful for example\n         // if we don't have the user's function\n         let nb_points = tf1.fNpx,\n             xmin = tf1.fSave[nb_points + 1],\n             xmax = tf1.fSave[nb_points + 2];\n\n         return Math.abs(xmin - xmax) / nb_points < Math.abs(min - max);\n      }\n\n      // if function calculated, one always could zoom inside\n      return true;\n   }\n\n   /** @summary draw TF1 object */\n   static draw(dom, tf1, opt) {\n      let painter = new TF1Painter(dom, tf1, opt),\n          d = new DrawOptions(opt),\n          has_main = !!painter.getMainPainter(),\n          aopt = \"AXIS\";\n      d.check('SAME'); // just ignore same\n      if (d.check('X+')) { aopt += \"X+\"; painter.second_x = has_main; }\n      if (d.check('Y+')) { aopt += \"Y+\"; painter.second_y = has_main; }\n      if (d.check('RX')) aopt += \"RX\";\n      if (d.check('RY')) aopt += \"RY\";\n\n      proivdeEvalPar(tf1);\n\n      let pr = Promise.resolve(true);\n\n      if (!has_main || painter.second_x || painter.second_y)\n         pr = TH1Painter.draw(dom, painter.createDummyHisto(), aopt);\n\n      return pr.then(() => {\n         painter.addToPadPrimitives();\n         painter.redraw();\n         return painter;\n      });\n   }\n\n} // class TF1Painter\n\nexport { TF1Painter, proivdeEvalPar };\n","import { TGraphPainter as TGraphPainter2D } from '../hist2d/TGraphPainter.mjs';\nimport { TH1Painter } from './TH1Painter.mjs';\nimport { createLineSegments, create3DLineMaterial } from '../base/base3d.mjs';\n\n\nclass TGraphPainter extends TGraphPainter2D {\n\n   /** @summary Draw TGraph points in 3D\n     * @private */\n   drawBins3D(fp, graph) {\n\n      if (!fp.mode3d || !fp.grx || !fp.gry || !fp.grz || !fp.toplevel)\n         return console.log('Frame painter missing base 3d elements');\n\n      if (fp.zoom_xmin != fp.zoom_xmax)\n        if ((this.options.pos3d < fp.zoom_xmin) || (this.options.pos3d > fp.zoom_xmax)) return;\n\n      let drawbins = this.optimizeBins(1000),\n          first = 0, last = drawbins.length-1;\n\n      if (fp.zoom_ymin != fp.zoom_ymax) {\n         while ((first < last) && (drawbins[first].x < fp.zoom_ymin)) first++;\n         while ((first < last) && (drawbins[last].x > fp.zoom_ymax)) last--;\n      }\n\n      if (first == last) return;\n\n      let pnts = [], grx = fp.grx(this.options.pos3d),\n          p0 = drawbins[first];\n\n      for (let n = first + 1; n <= last; ++n) {\n         let p1 = drawbins[n];\n         pnts.push(grx, fp.gry(p0.x), fp.grz(p0.y),\n                   grx, fp.gry(p1.x), fp.grz(p1.y));\n         p0 = p1;\n      }\n\n      let lines = createLineSegments(pnts, create3DLineMaterial(this, graph));\n\n      fp.toplevel.add(lines);\n\n      fp.render3D(100);\n   }\n\n   /** @summary Draw axis histogram\n     * @private */\n   drawAxisHisto() {\n      let histo = this.createHistogram();\n      return TH1Painter.draw(this.getDom(), histo, this.options.Axis);\n   }\n\n   static draw(dom, graph, opt) {\n      return TGraphPainter._drawGraph(new TGraphPainter(dom, graph), opt);\n   }\n\n} // class TGraphPainter\n\nexport { TGraphPainter };\n"],"x_google_ignoreList":[0,1,2]}